# 代码随想录
~~~
计划 : 因为之前已经做过很多了,所以进度要快一些
数组 : 8 / 17  -- 8 / 17 完成
链表 : 8 / 18  -- 8 / 17 完成
哈希表 : 8 / 19 -- 8 / 18完成
字符串 : 8 / 20  -- 8 / 19完成
双指针 : 8 / 21  -- 8 / 19完成
栈与队列 : 8 / 22 -- 8 / 20完成
二叉树 : 8 / 23 - 8 / 24 -- 8 / 24凌晨完成
回溯算法 : 8 / 25 - 8 / 26  -- 8 / 31号完成
贪心 : 8 / 27 - 8 / 28 -- 9 / 2号上午完成
动态规划 : 8 / 29 - 8 / 31 -- 9 / 8号上午完成

单调栈 和 额外题目 : 9 / 1 - 9 / 3
图论 -- 9.12

最终完成时间 -- 9 / 12 日完成
~~~
## Array

### 704. 二分查找...
~~~
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;int right = nums.size()-1;
        
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid-1;
            }else{
                left = mid + 1;
            }
        }
        return -1;
    }
};
~~~


### 27.移除元素
思路一 : 双指针法
~~~
class Solution {
public:
    void swap(int&a,int&b){int tmp = a;a = b;b =tmp;}
    int removeElement(vector<int>& nums, int val) {
        int left = 0;int right = nums.size() - 1;
        while(right >= 0 && left < nums.size() && left < right)
        {
            while(left < nums.size() && nums[left] != val ){
                left++;
            }

            while(right >= 0 && nums[right] == val ){
                right--;
            }

            if(left < right)
                swap(nums[left],nums[right]);
        }


        int count = 0;
        while(count < nums.size() && nums[count] != val){
            count++;
        }

        return count;
    }
};
~~~
这里是前后两个指针,有时候会用到快慢两个指针...感觉快慢指针用起来可能方便一些..
以后可以试试


### 997.有序数组的平方
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

思路1 : 还是双指针,left指向非负,right指向负
~~~
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        if(nums.empty())
        {
            return {};
        }
        vector<int>res;
        //感觉还是双指针...
        //left指向绝对值最小的负数,right指向绝对值小的非负数.
        //比较绝对值的大小...

        int left = 0,right = 0;
        //寻找第一个非负数
        while(right < nums.size() && nums[right] < 0){
            right++;
        }
        if(right == 0)//数组为空或者从第一个开始就是非负数
        {
            for(auto v : nums){
                res.push_back(pow(v,2));
            }
            return res;
        }
        else if(right == nums.size())
        {
            //数组为空或者数组全部是负数
            for(auto v : nums){
                res.push_back(pow(v,2));
            }
            //颠倒一下
            reverse(res.begin(),res.end());
            return res;
        }
        else //有正有负
        {
            left = right - 1;//left 指向绝对值最小的负数
            while(left >= 0 && right < nums.size())
            {
                if(abs(nums[left]) < abs(nums[right]))
                {
                    res.push_back(pow(nums[left--],2));
                }
                else
                {
                    res.push_back(pow(nums[right++],2));
                }
            }

            while(left >= 0){
                res.push_back(pow(nums[left--],2));
            }
            while(right < nums.size()){
                res.push_back(pow(nums[right++],2));
            }

            return res;
        }

    }
};
~~~
这样的写法繁琐了...从中间开始判断增加了很多冗余的判断,事实上我们可以从两端开始周三后.会方便很多...
~~~
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        if(nums.empty())
        {
            return {};
        }
        vector<int>res(nums.size());
        int index = nums.size() -1;
        //感觉还是双指针...
        //left指向绝对值最小的负数,right指向绝对值小的非负数.
        //比较绝对值的大小...
        //从两端开始
        int left = 0;int right = nums.size() - 1;
        
        while(left < nums.size() && right >= 0 && left <= right)
        {
            if(abs(nums[left]) < abs(nums[right])){
                res[index--] = (nums[right] * nums[right]);
                right--;
            }else{
                res[index--] = (nums[left] * nums[left]);
                left++;
            }
        }
        
        return res;

    }
};
~~~

### 209.长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

思路一 : 滑动窗口
~~~
class Solution {
public:
    //返回和 >= target的长度最小的连续子数组
    //关键词 : 连续
    //暴力 : 一次以每个元素开头,计算最小子数组的长度,返回最小值
    //滑动窗口 : 有窗口头,和窗口尾,两个状态 : 如果总长度够了 , 头 + 1, 长度不够,尾长度 + 1,且当前的窗口总行度增加
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty())
            return 0;
        if(accumulate(nums.begin(),nums.end(),0) < target)
            return 0;
        
        int left = 0, right = 0,cur_sum = 0;
        int min_len = INT_MAX;
        cur_sum = nums[left];

        while(right < nums.size())
        {
            if(cur_sum < target)
            {
                //是否有增长的能力
                if(right + 1 >= nums.size()){
                    return min_len;
                }else{
                    cur_sum += nums[++right];
                }
            }
            else // >= target
            {
                //是否是最小值
                min_len = (right - left + 1) < min_len ? (right - left + 1) : min_len;
                //尝试缩减
                cur_sum -= nums[left++];
            }
        }
        
        return min_len;
    }
};
~~~


### 59.螺旋矩阵
给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]


//状态机的思想真是让人受益...

~~~
class Solution {
public:
//经过观察,当前的正方体为n,每次填充n-1个方块,
/*
1 1 1
1 1 1
1 1 1

1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
*/
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>res(n,vector<int>(n,0));
        int dircetion = 0;//0 -- 右 1 -- 下 2 -- 左 3 -- 上
        int x = 0;
        int y = 0;
        int cur_val = 1;
        int count = n - 1;
        while(count > 0)
        {
            if(dircetion == 0){
                for(int i = 0;i<count;i++){
                    res[x][y++] = cur_val++;
                }
                dircetion = 1;
            }else if(dircetion == 1){
                for(int i = 0;i<count;i++){
                    res[x++][y] = cur_val++;
                }
                dircetion = 2;
            }else if(dircetion == 2){
                for(int i = 0;i<count;i++){
                    res[x][y--] = cur_val++;
                }
                dircetion = 3;
            }else if(dircetion == 3){
                for(int i = 0;i<count;i++){
                    res[x--][y] = cur_val++;
                }
                dircetion = 0;
                count -= 2;
                x+=1;y+=1;//base变化
            }else{
                printf("error");
                return {};
            }
        }

        if(count == 0)//n为奇数填充中间
        {
            res[n/2][n/2] = pow(n,2);
        }
        return res;
    }
};

~~~



### 35.搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

~~~
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        //典中典值二分查找
        int left = 0;int right = nums.size() - 1;

        while(left < right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        
        //left == right
        if(nums[left] >= target)
            return left;
        else
            return left + 1;
        
    }
};
~~~



## List
最简单的一集,小时候写链表笑出声了...

### 203.移除链表元素
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 
思路一 : 递归写法
~~~
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //试试递归
        if(!head)
            return head;
        
        if(head->val == val){
            return removeElements(head->next,val);
        }

        head->next = removeElements(head->next,val);

        return head;
    }
};
~~~

思路二 : 迭代的写法...(每写一个while,要明确while结束时程序的状态);
~~~
ListNode* removeElements(ListNode* head, int val) {
        //试试迭代的写法
        if(!head)
            return head;

        ListNode* tmp = new ListNode(-1);
        ListNode* pre = tmp;
        ListNode* cur = head;
        
        while(cur)
        {
            if(cur->val == val)
            {
                cur = cur->next;
            }
            else
            {
                pre->next = cur;
                pre = cur;
                cur = cur->next;
                pre->next = nullptr;
            }
        }

        return tmp->next;
    }
~~~


### 707.设计链表
在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点

...看着简单,实际上还是有些细节需要注意
~~~
class MyLinkedList {
public:
    struct Node
    {
        int val;
        Node* next;

        Node(int v,Node* n = nullptr):
            next(n),
            val(v)
        {}
    };

    Node* head;

    MyLinkedList() {
        head = nullptr;
    }
    
    int get(int index) {
        Node* cur = head;
        for(int i = 0;i<index;i++){
            if(!cur){
                return -1;
            }else{
                cur = cur->next;
            }
        }

        if(!cur){
            return -1;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        Node* node = new Node(val);
        if(!head){
            head = node;
        }else{
            node->next = head;
            head = node;
        }
    }
    
    void addAtTail(int val) {
        Node* node = new Node(val);
        Node* cur = head;
        Node* pre = nullptr;
        while(cur){
            pre = cur;
            cur = cur->next;
        }
        if(!pre){
            head = node;
        }else{
            pre->next = node;
        }

        //打印一哈
        cur = head;
        
    }
    
    void addAtIndex(int index, int val) {
        Node* pre = nullptr;
        Node* cur = head;
        for(int i = 0;i<index;i++){
            if(!cur){
                return;
            }else{
                pre = cur;
                cur = cur->next;
            }
        }

        if(!cur){
            addAtTail(val);
        }

        if(!pre){
            //在头结点插入
            addAtHead(val);
            return;
        }
        Node* node = new Node(val);
        pre->next = node;
        node->next = cur;
        
    }
    
    void deleteAtIndex(int index) {
        if(!head){
            return;
        }
        
        Node* pre = nullptr;
        Node* cur = head;
        for(int i = 0;i<index;i++)
        {
            pre = cur;
            cur = cur->next;
            if(!cur)
                return;
        }
        if(!pre){
            //该判断还是要判断...
            //删除头结点
            Node* tmp =head;
            head = head->next;
            delete tmp;

            return ;
        }
        //cur指向index的节点且节点存在
        pre->next = cur->next;
        delete cur;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
~~~

### 206.反转链表
典中典中典
~~~
ListNode* reverseList(ListNode* head) {
    //从后往前将链表的节点翻转
    if(!head || !head->next)
        return head;
    //head->head->next->head->next->next...
    ListNode* node = reverseList(head->next);

    head->next->next = head;
    head->next = nullptr;

    return node;
}
~~~

### 24.两两交换链表中的结点
链表问题很多时候引入一个开头的僵尸节点就会方便很多很多...
~~~
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        ListNode* tmp = dummy;
        tmp->next = head;

        //存在两个组对的节点
        while(tmp->next && tmp->next->next)
        {
            ListNode* left = tmp->next;
            ListNode* right = tmp->next->next;

            tmp->next = right;
            left->next = right->next;
            right->next = left;
            //交换完成
            tmp = left;//tmp指向下一对节点的前一个节点
        }

        ListNode*res = dummy->next;
        delete dummy;
        return res;
    }
~~~


### 19.删除链表的倒数第N个节点
典
~~~
ListNode* removeNthFromEnd(ListNode* head, int n) {
        //删倒数第N个,就是要找倒数第N+1个节点...
        if(!head){return head;}

        ListNode* fast = head;
        for(int i = 0;i<n;i++)
        {
            fast = fast->next;
        }
        if(!fast)
        {
            //要删除的就是头结点
            ListNode* tmp =head;
            head = head->next;
            delete tmp;
            return head;
        }

        ListNode* slow = head;
        while(fast->next){
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* t = slow->next;
        slow->next = slow->next->next;
        delete t;

        return head;
    }
~~~


### 02.07. 链表相交
典!
~~~
   int getListLen(ListNode* head)
    {
        int count = 0;
        while(head){
            count++;
            head = head->next;
        }

        return count;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getListLen(headA);
        int lenB = getListLen(headB);

        ListNode* theLong = lenA > lenB ? headA : headB;
        ListNode* theShort = lenA > lenB ? headB : headA;

        int interval = abs(lenA - lenB);
        for(int i = 0;i<interval;i++){
            theLong = theLong->next;
        }

        while(theLong && theShort){
            if(theLong == theShort){
                return theLong;
            }
            theLong = theLong->next;
            theShort = theShort->next;
        }

        return nullptr;
    }
~~~


### 142. 环形链表2
...链表题目怎么都是典中典???
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。


经典的快慢指针...
快慢指针相遇于        A点
x + A->尾 + 尾-> 环的开始 -> A典 = 2x
即 x = A->tail + tail -> 环的开始.
所以快指针这时候回到开头,然后和慢指针一样的速度前进就可以和慢指针在环开始的地方相遇
~~~
ListNode *detectCycle(ListNode *head) {
        if(!head){return nullptr;}
        ListNode* fast = head;
        ListNode* slow = head;

        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;

            if(fast == slow){
                break;
            }
        }

        if(!fast || !fast->next){
            return nullptr;
        }

        fast = head;
       
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
            
        }

        return fast;
    }

~~~


## Hash Table
### 242. 有效的字母异位词
~~~
bool isAnagram(string s, string t) {
    //首先记录s每个字符出现的次数....
    int hash[26]{0};
    for(auto ch : s){
        hash[ch - 'a']++;
    }

    for(auto ch : t){
        hash[ch - 'a']--;
        if(hash[ch - 'a'] < 0){
            return false;
        }
    }

    for(int i = 0;i<26;i++){
        if(hash[i] != 0){
            return false;
        }
    }

    return true;
}
~~~
### 349.两个数组的交集
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 

~~~
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    vector<int> res;
    int hash[1024]{0};
    for(auto num : nums1){
        hash[num]++;
    }

    for(auto num : nums2){
        if(hash[num] > 0){
            res.push_back(num);
            hash[num] = 0;
        }
    }

    return res;
}
~~~


### 202.快乐数
~~~
    //根据数字计算平方和
    int powerSum(int n)
    {
        int res = 0;
        while(n){
            res += (n%10) * (n%10);
            n /= 10;
        }

        return res;
    }
    bool isHappy(int n) {
        set<int> repeat;
        
        while(n != 1)
        {
            n = powerSum(n);
            if(repeat.find(n) != repeat.end()){
                return false;
            }
            repeat.insert(n);
        }
        return true;

    }
~~~


### 1.两数之和
...梦开始的地方...
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

~~~
vector<int> twoSum(vector<int>& nums, int target) {
        //梦开始的地方
        unordered_map<int,int>hash_map;//val - index
        
        for(int i = 0;i<nums.size();i++)
        {
            auto iter = hash_map.find(target - nums[i]);
            if(iter != hash_map.end()){
                return {iter->second,i};
            }
            hash_map.insert({nums[i],i});
        }

        
        return {};
    }
~~~


### 454.四数相加
~~~
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        //...遍历nums1 , nums2 ,两两相加加入hash表,然后遍历Nums3 , nums4两两相加,然后寻找hash表内是否存在负值
        unordered_map<int,int>hash;
        for(auto v1 : nums1)
        {
            for(auto v2 : nums2)
            {
                hash[v1 + v2]++;
            }
        }

        int res = 0;
        for(auto v3 : nums3)
        {
            for(auto v4 : nums4)
            {
                int n = v3 + v4;
                auto iter = hash.find(-n);
                if(iter != hash.end()){
                    res += iter->second;
                }
            }
        }

        return res;
    }
~~~


### 383.赎金信
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。
~~~
bool canConstruct(string ransomNote, string magazine) {
    unordered_map<char,int>hash;
    for(auto ch : magazine){
        hash[ch]++;
    }

    for(auto ch : ransomNote){
        if(--hash[ch] < 0){
            return false;
        }
    }

    return true;
}
~~~

### 15.三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 //...这题似乎并不适合用哈希表的方法去做.因为无论怎样都要包含
 ~~~
    vector<vector<int>> threeSum(vector<int>& nums){
        vector<vector<int>>res;
        //将nums排序,方便去重
        sort(nums.begin(),nums.end());

        for(int i = 0;i<nums.size();i++)
        {
            unordered_set<int>hash;
            //最小的元素 > 0,不可能有三元组
            if(nums[i] > 0)
                break;
            
            if(i > 0 && nums[i] == nums[i-1]){
                continue;//跳过重复
            }
            
            for(int j = i + 1;j < nums.size();j++)
            {
                //b 和 c不能相等两次,连续的三个数字不能相等,否则会出现b的重复选择.
                if(j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]){
                    continue;
                }

                int n = -(nums[i] + nums[j]);
                if(hash.find(n)!= hash.end()){
                    res.push_back({nums[i],nums[j],n});
                    hash.erase(n);
                }else{
                    hash.insert(nums[j]);//nums[j]是b
                }
                
                
            }
            
        }
        return res;
    }
~~~
去重去的头疼....

更好的解法 : 双指针法
~~~
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>>res;
        sort(nums.begin(),nums.end());
        if(nums.size() < 3){
            return {};
        }
        for(int i = 0;i<nums.size()-2;i++)
        {
            //i去重
            if(nums[i] > 0)
                break;

                
            if(i > 0 && nums[i] == nums[i-1])
                continue;

            int left = i + 1;int right = nums.size()-1;
            while(left < nums.size()-1 && right > i+1 && left < right)
            {
                //left去重
                if(left > i + 1)
                {
                    if(nums[left] == nums[left-1])
                    {
                        left++;
                        continue;
                    }
                }

                //right去重
                if(right < nums.size()-1){
                    if(nums[right] == nums[right+1]){
                        right--;
                        continue;
                    }
                }

                int cur_val = nums[i] + nums[left] + nums[right];
                if(cur_val == 0){
                    res.push_back({nums[i],nums[left],nums[right]});
                    left++;right--;//找到答案,同时收缩.
                }else if(cur_val > 0){
                    //过大,right左移
                    right--;
                }else{
                    //过小,left右移动
                    left++;
                }

            }
        }

        return res;
    }
~~~
...感觉有点像滑动窗口



### 18.四数之和
~~~
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>>res;
    sort(nums.begin(),nums.end());
    for(int i = 0;i<nums.size();i++)
    {
        if(nums[i] > target && nums[i] >= 0)
            break;

        if(i > 0 && nums[i] == nums[i-1]){
            continue;
        }
        for(int j = i + 1;j<nums.size();j++)
        {
            if(nums[i] + nums[j] > target && nums[i] + nums[j] >= 0)
                break;

            if(j > i + 1 && nums[j] == nums[j-1]){
                continue;
            }

            int left = j + 1; int right = nums.size()-1;
            while(left < right)
            {
                
                if((long) nums[i] + nums[j] + nums[left] + nums[right] < target){
                    left++;
                }else if((long) nums[i] + nums[j] + nums[left] + nums[right] > target){
                    right--;
                }else{
                    res.push_back({nums[i],nums[j],nums[left],nums[right]});
                    while(left < right && nums[left] == nums[left+1])left++;
                    while(left < right && nums[right] == nums[right-1]) right--;

                    left++;
                    right--;
                }
            }
        }
    }

    return res;
}
~~~



## String

### 344. 反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题

...ez
~~~
void reverseString(vector<char>& s) {
    int left = 0;int right = s.size()-1;
    while(left < right)
    {
        swap(s[left++],s[right--]);
    }
}
~~~


### 541.反转字符串2.0
~~~
void func(string& s,int index,int length)
{
    int left = index;
    int right = index + length - 1;

    while(left < right)
    {
        swap(s[left++],s[right--]);
    }
}
string reverseStr(string s, int k) {
    int index = 0;  
    int size = s.size();

    while(index < size)
    {
        //看看够不够k
        if(index + k - 1 < size)
        {
            func(s,index,k);
        }
        else
        {
            //不够k
            func(s,index,size - index);
        }
        index += 2 * k;
    }
    
    return s;
}
~~~


### 剑指Offer 05.替换空格
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1： 输入：s = "We are happy."
输出："We%20are%20happy."

不能使用额外的内存空间
~~~
string replaceSpace(string s) {
    //要求不能使用额外的地址空间...
    int count = 0;
    for(auto ch : s)
    {
        if(ch == ' ')
            count++;
    }

    int front = s.size() - 1;
    s.resize(s.size() + 2 * count);

    //两个指针从后往前,如果直到前面的指针 == 0
    int last = s.size()-1;

    while(front >= 0)
    {
        if(s[front] == ' ')
        {
            s[last--] = '0';
            s[last--] = '2';
            s[last--] = '%';
            front--;
        }
        else
        {
            s[last--] = s[front--];
        }
    }

    return s;
}
~~~


### 151.反转字符串种的单词
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。


不能使用辅助空间...

移除字符串中所有额外的字符串写的很好.
用for(;;)(if(s[i] != ) {} ) 去排除空格的情况,这样的filter写法学到了...
~~~
class Solution {
public:
    void reverse(string& s,int start,int end)
    {
        while(start < end)
        {
            swap(s[start++],s[end--]);
        }
    }

    //移除字符串所有中的字符串
    void removeExtraSpaces(string&s)
    {
        int slow = 0;
        for(int i = 0;i < s.size();i++)
        {
            //如果遇到的不是空格我就自己加上一个空格
            if(s[i] != ' ')
            {
                if(slow != 0)//并不位于开头
                {
                    s[slow++] = ' ';
                }
                //开始录入单词
                while(i < s.size() && s[i] != ' '){
                    s[slow++] = s[i++];
                }
            }
        }

        s.resize(slow);

    }
    //不能使用辅助空间
    string reverseWords(string s) {
        //首先去除所有的空格...,先整体反转一遍...然后对每个单词进行翻转
        removeExtraSpaces(s);

        //整体翻转
        reverse(s,0,s.size()-1);

        for(int i = 0;i<s.size();i++)
        {
            if(s[i] != ' ')
            {
                int fast = i;
                while(fast < s.size() && s[fast] != ' ')
                    fast++;
                //定位到单词,开始反转
                reverse(s,i,fast-1);
                i = fast;
            }
        }

        return s;
    }
};
~~~


### 剑指offer 58-2 .左旋转字符串
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

~~~
    //将前面的n个转移到尾部
    string reverseLeftWords(string s, int n) {
        //首先计算出需要左移的实际的数量
        n = n % s.size();

        string tmp;
        for(int i = 0;i<n;i++)
        {
            tmp.push_back(s[i]);
        }

        int left = 0;int right = n;
        while(right < s.size())
        {
            s[left++] = s[right++];
        }
        
        right = 0;
        while(left < s.size())
        {
            s[left++] = tmp[right++];
        }

        return s;
    }
~~~
如果不想要用到额外的空间的话...
首先将左侧即将移到后面的字符串先局部翻转,然后再对整个字符串进行整体反转,然后再对转移到左侧的字符串进行局部翻转.
~~~
class Solution {
public:
    //将前面的n个转移到尾部
    void reverse(string& s,int start,int end)
    {
        if(start >= end)
            return;
        while(start < end)
        {
            swap(s[start++],s[end--]);
        }
        
    }
    string reverseLeftWords(string s, int n) {
        //首先计算出需要左移的实际的数量
        n = n % s.size();

        reverse(s,0,n-1);

        reverse(s,n,s.size()-1);

        reverse(s,0,s.size()-1);


        return s;
    }
};
~~~


### 28.实现strStr() KMP算法
前缀表 : 用于回退,记录模式串和主串不匹配是,模式串应该从何处开始重新匹配.
记录下标i之前(包括i)的字符串中,有多大长度的相同前缀后缀

最长公共前后缀   
前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。
后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。

使用前缀表:
当匹配中遇到不匹配的字符串,查询前一位的前缀表的数值.

构造next数组
~~~
//构造next数组其实就是计算模式串s,前缀表的过程,主要有如下三步
/*
1.初始化
2.处理前后缀不同的情况
3.处理前后缀相同的情况
*/

void getNext(int *next,const string& s)
{
    int j = -1;
    next[0] = j;
    
    for(int i = 1;i < s.size();i++)
    {
        while(j >= 0 && s[i] != t[j+1]){
            //前后缀不相同的时候
            j = next[j];    
        }
        if(s[i] == s[j+1]){
            j++;
        }
        next[i] = j;
    }
}
~~~

~~~
    //创建next数组
    void getNext(int* next,string s)
    {
        int j = -1;
        next[0]  = j;

        for(int i = 1;i<s.size();i++)
        {
            while(j >= 0 && s[j+1] != s[i])
                j = next[j];

            if(s[j+1] == s[i])
            {
                j++;
            }

            next[i] = j;
        }
        
        for(int i = 0;i<s.size();i++)
        {
            cout<<next[i]<<" ";
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;


        int next[needle.size()];
        
        getNext(next,needle);

        int j = -1;
        for(int i = 0;i<haystack.size();i++)
        {
            while(j >= 0 && haystack[i] != needle[j+1])
            {
                j = next[j];
            }

            if(haystack[i] == needle[j+1])
                j++;

            if(j == needle.size() -1)
                return i - j;
        }

        return -1;
    }
~~~

//总感觉-1有点反直觉,不减1的版本
~~~
   void getNextArray(int*next,string s)
    {
        int j = 0;
        next[0] = j;

        for(int i = 1;i<s.size();i++)
        {
            while(j > 0 && s[i] != s[j])
            {
                j = next[j-1];
            }

            if(s[i] == s[j])
            {
                j++;
            }

            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        int next[needle.size()];
        getNextArray(next,needle);

        for(auto val : next){
            cout<<val<<" ";
        }
        int j = 0;
        for(int i = 0;i<haystack.size();i++)
        {
            while(j > 0 && haystack[i] != needle[j]){
                j = next[j-1];
            }

            if(haystack[i] == needle[j])
            {
                j++;
            }

            if(j == needle.size())
                return i - j + 1;
        }

        return -1;
    }
~~~


### 459.重复的子字符串
给定一个非空的字符串s,检查是否可以通过它的一个子串重复多次构成...

巧妙的解法 : 如果一个字符串由重复的字符串组成,那么两个字符串的中间一定会再次出现一次这个字符串
~~~
bool repeatedSubstringPattern(string s) {
        string ss = s + s;
        ss.erase(ss.begin());
        ss.erase(ss.end()-1);

        
        return (ss.find(s) != string::npos);
    }
~~~


### 27.移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
...之前都写过一遍了...

~~~
int removeElement(vector<int>& nums, int val) {
        //替换而不是交换
        int slow = 0;
        for(int fast = 0;fast < nums.size();fast++)
        {
            if(nums[fast] != val)
            {
                nums[slow++] = nums[fast];
            }
        }

        return slow;

    }
~~~


这里还有几题上面都做过了...不想再做第二遍


## Stack And Queue

### 232.用栈实现队列
用两个栈实现队列


操作时间平均复杂是O(1)
~~~
class MyQueue {
public:
    stack<int>s1;
    stack<int>s2;

    //入队都放在s1内,
    //出队从s2出,如果s2为空,则将s1的东西都放进s2

    MyQueue() {

    }
    
    void push(int x) {
        s1.push(x);
    }
    
    int pop() {
        if(s2.empty()){
            while(!s1.empty()){
                s2.push(s1.top());
                s1.pop();
            }
        }

        int top = s2.top();
        s2.pop();
        return top;
    }
    
    int peek() {
        if(s2.empty()){
            while(!s1.empty()){
                s2.push(s1.top());
                s1.pop();
            }
        }

        int top = s2.top();

        return top;
    }
    
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
~~~


### 225.用队列实现栈
两个队列实现一个栈
..一个队列就能实现


### 20.有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。


~~~
bool isValid(string s) {
        stack<char> st;
        for(auto ch : s)
        {
            if(ch == '(' || ch == '{' || ch == '[')
            {
                st.push(ch);
            }
            else if(ch == ')')
            {
                if(st.empty()||st.top() != '(' )
                    return false;
                else{
                    st.pop();
                }
            }
            else if(ch == ']')
            {
                if(st.empty() || st.top() != '[')
                    return false;
                else{
                    st.pop();
                }
            }
            else if(ch == '}')
            {
                if(st.empty() || st.top() != '{')
                    return false;
                else{
                    st.pop();
                }
            }
        }

        return st.empty();
    }
~~~

这样写代码冗余比较严重我们可以在检测到左括号的时候入栈右括号,然后遇到右括号是判断相等即可
~~~
 bool isValid(string s) {
        stack<char> st;
        if(s.size() % 2 != 0)
            return false;
        
        for(auto ch :s)
        {
            if(ch == '(') st.push(')');
            else if(ch == '[') st.push(']');
            else if(ch == '{') st.push('}');
            else if(st.empty() || st.top() != ch){
                return false;
            }else{
                st.pop();
            }

        }

        return st.empty();
    }
~~~


### 150.逆波兰表达式
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。


### 239.滑动窗口的最大值

根据题目需要自己写合适的数据结构,这样的方法比用过程式编程的想法要更方便.
总的来说还是状态机的思想

单调队列 : 维护队列中永远是从大到小的排列.且至少有一个元素.


~~~
class Solution {
    class Queue
    {
    private:
        deque<int> deq;
    public:
        //队头是当前最大的元素
        void pop(int value)
        {
            //如果value是队头元素则pop
            if(!deq.empty() && deq.front() == value)
            {
                deq.pop_front();
            }
        }

        void push(int value)
        {
            //将比value小的元素都出队,然后
            while(!deq.empty() && deq.back() < value){
                deq.pop_back();
            }

            deq.push_back(value);
        }

        int top(){
            return deq.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int>res;
        
        Queue queue;

        //初始化
        for(int i = 0;i<k;i++)
        {
            queue.push(nums[i]);
        }

        res.push_back(queue.top());


        //开始滑动
        for(int i = k;i<nums.size();i++)
        {
            queue.pop(nums[i-k]);
            queue.push(nums[i]);

            res.push_back(queue.top());
        }


        return res;
    }
};
~~~


### 347.前K个高频元素
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

//典中典之TopK问题...
思路一 : 用大根堆存放pair,然后输出
~~~
class Solution {
public:
    class Comp
    {
    public:
        bool operator()(pair<int,int>pair1,pair<int,int>pair2)
        {
            return pair1.second < pair2.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>hash;
        for(auto val : nums)
        {
            hash[val]++;
        }

        //用大根堆吧
        priority_queue<pair<int,int>,vector<pair<int,int>>,Comp>bigHeap;

        //开始入队
        for(auto pair : hash)
        {
            bigHeap.push(pair);
        }


        vector<int>res;
        for(int i = 0;i < k;i++)
        {
            cout<<"bigHeap.top() = "<<bigHeap.top().first<<endl;
            res.push_back(bigHeap.top().first);
            bigHeap.pop();
        }

        return res;
    }
};
~~~


## binary tree

### 首先是各种遍历,分为递归实现和非递归实现
~~~
//中序遍历(递归)
void LVR(TreeNode* node)
{
    if(!node)
        return;
    LVR(node->left);
    res.push_back(node->val);
    LVR(node->right);
}

//前序遍历
void LVR(TreeNode* node)
{
    if(!node)
        return;
    res.push_back(node->val);   
    LVR(node->left);
    
    LVR(node->right);
}

//后续遍历
void LVR(TreeNode* node)
{
    if(!node)
        return;
    
    LVR(node->left);
    LVR(node->right);
    res.push_back(node->val);   
}



//前序遍历(迭代)
用一个栈保存根节点,先访问左节点直到没有左节点了,退回栈中的上一个根节点
void VLR(TreeNode* node)
{
    stack<TreeNode*> st;
    TreeNode* cur = node;
    while(cur || !st.empty())
    {
        while(cur)
        {
            res.push_back(cur->val);
            //进入左节点前将本节点加入栈
            st.push(cur);
            cur = cur->left;
        }

        if(!st.empty())
        {
            TreeNode* node = st.top();
            st.pop();
            if(node->right){
                cur = node->right;
            }
        }
    }
}


//中序遍历(迭代)
void LVR(TreeNode* node)
{
    TreeNode* cur = node;
    stack<TreeNode*> st;
    //首先访问左边的节点
    while(cur || !st.empty())
    {
        while(cur){
            st.push(cur);
            cur = cur->left;
        }

        if(!st.empty())
        {
            cur = st.top();
            st.pop();
            res.push_back(cur->val);
            cur = cur->right;
        }
    }
}


//后序遍历
void LRV(TreeNode* node){
        //后续遍历,LRV,因为可能存在遍历两次的情况,所以需要一个哈希表帮忙识别是否是第一次入栈
        stack<TreeNode*>st;
        unordered_set<TreeNode*>hash;

        TreeNode* cur =node;
        while(cur || !st.empty())
        {
            while(cur){
                st.push(cur);
                cur = cur->left;
            }
            //这时候遍历cur == nullptr 到最左端的节点,需要向右遍历
            if(!st.empty())
            {
                cur = st.top();
                st.pop();
                //询问是否是第一次入栈
                if(hash.find(cur) == hash.end())
                {
                    hash.insert(cur);
                    st.push(cur);
                    cur = cur->right;
                }
                else
                {
                    res.push_back(cur->val);
                    cur = nullptr;
                }
            }
        }
    }


//层序遍历
//用一个队列,类似于广度优先
void LevelOrder(BinTree* root){
    queue<BinTree*> m_queue;
    if(!root){
        return;
    }
    BinTree* tmp;
    q.push(root);
    while(!q.empty()){
    	tmp = q.front();
        q.pop();
        cout<<tmp->val<<endl;
        if(tmp->left){
            q.push(tmp->left);
        }
        if(tmp->right){
            q.push(tmp->right);
        }
    }
}
~~~

### 199.二叉树的右视图
~~~
vector<int> rightSideView(TreeNode* root) {
        //层序遍历
        if(!root){
            return {};
        }
        vector<int>res;
        queue<TreeNode*>que;
        que.push(root);
        while(!que.empty())
        {
            //将每一层的最右边的节点入列,将每一层的所有子节点加入
            int size = que.size();
            for(int i = 0;i<size;i++)
            {
                TreeNode* front = que.front();
                if(front->left){
                    que.push(front->left);
                }
                if(front->right){
                    que.push(front->right);
                }
                
                if(i == size -1)
                {
                    //最右侧的节点,加入res
                    res.push_back(front->val);
                }
                que.pop();
            }
            
        }

        return res;
    }
~~~


### 116.填充每个节点的下一个右侧节点指针
给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

~~~
    Node* connect(Node* root) {
        //层序遍历,对于每一行,指向向右的的节点
        if(!root){
            return root;
        }

        queue<Node*> que;
        que.push(root);

        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0;i<size;i++)
            {
                Node* front = que.front();
                que.pop();
                if(i == size-1){
                    front->next = nullptr;
                }else{
                    front->next = que.front();
                }

                if(front->left){
                    que.push(front->left);
                }

                if(front->right){
                    que.push(front->right);
                }
            }
        }

        return root;
    }
~~~


### 117.填充每个节点的下一个右侧指针 2.0

哈哈,上题的答案可以直接套用
~~~
//层序遍历,对于每一行,指向向右的的节点
        if(!root){
            return root;
        }

        queue<Node*> que;
        que.push(root);

        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0;i<size;i++)
            {
                Node* front = que.front();
                que.pop();
                if(i == size-1){
                    front->next = nullptr;
                }else{
                    front->next = que.front();
                }

                if(front->left){
                    que.push(front->left);
                }

                if(front->right){
                    que.push(front->right);
                }
            }
        }

        return root;

~~~


### 104.二叉树的最大深度
~~~
int maxDepth(TreeNode* root) {
        return root ? 1 + max(maxDepth(root->left),maxDepth(root->right)) : 0;
    }
~~~


### 111.二叉树的最小深度
~~~
int minDepth(TreeNode* root) {
        //用层序遍历试试,返回除了第一个没有左右子树的节点的深度
        if(!root){
            return 0;
        }
        queue<TreeNode*> que;
        que.push(root);
        int depth = 0;
        while(!que.empty())
        {
            int size = que.size();
            depth++;
            for(int i = 0;i<size;i++)
            {
                TreeNode* front = que.front();
                if(!front->left && !front->right){
                    return depth;
                }
                if(front->left){
                    que.push(front->left);
                }

                if(front->right){
                    que.push(front->right);
                }

                que.pop();
            }
        }
        

        return -1;
    }
~~~


### 226.翻转二叉树
~~~
TreeNode* invertTree(TreeNode* root) {
    if(!root)
        return root;
    TreeNode* tmp = root->left;
    root->left = root->right;
    root->right = tmp;
    invertTree(root->left);
    invertTree(root->right);


    return root;
}
~~~


### 101.对称二叉树
~~~
//比较左右节点是否对称
bool compare(TreeNode* left,TreeNode* right)
{
    if(!left && !right)
        return true;
    if(!left || !right){
        return false;
    }

    if(left->val != right->val)
        return false;
    
    return compare(left->left,right->right) && compare(left->right,right->left);
}
//将根节点的左右节点
bool isSymmetric(TreeNode* root) {
    if(!root)
        return true;
    
    return compare(root->left,root->right);
    
}
~~~


### 222.完全二叉树的节点个数
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

~~~
int countNodes(TreeNode* root) {
    if(!root)
    {
        return 0;
    }

    int count = 1;
    if(root->left){
        count += countNodes(root->left);
    }

    if(root->right){
        count+= countNodes(root->right);
    }
    
    return count;
}
~~~


### 110.平衡二叉树
判断是否是平衡二叉树

这样写虽然能通过,但是算高度这一步重复计算了好多次...
~~~
int height(TreeNode* node)
{
    return node ? 1 + max(height(node->left),height(node->right)) : 0;
}
bool isBalanced(TreeNode* root) {
    if(!root)
        return true;

    int left = height(root->left);
    int right = height(root->right);

    if(abs(left - right) > 1)
        return false;
    
    return isBalanced(root->left) && isBalanced(root->right);
    
}
~~~

尝试优化一下,使用后续遍历,这样的事件复杂度被优化为O(n)
~~~
int heigth(TreeNode* node)
{
    if(!node)
        return 0;

    int left = heigth(node->left);
    if(left == -1)
        return -1;
    int right = heigth(node->right);
    if(right == -1)
        return -1;
    return abs(left - right) < 2 ? max(left , right) + 1 : -1;
    
}
bool isBalanced(TreeNode* root) {
    //后续遍历
    return heigth(root) != -1;
}
~~~


### 257.二叉树的所有路径
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。
~~~
vector<string>res;

void VLR(TreeNode* node,string &parentStr)
{
    string tmp = parentStr;
    if(node->left){
        tmp += "->";
        tmp+=to_string(node->left->val);
        VLR(node->left,tmp);
    }
    tmp = parentStr;
    if(node->right){
        tmp += "->";
        tmp+=to_string(node->right->val);
        VLR(node->right,tmp);
    }


    if(!node->left && !node->right)
        res.push_back(tmp);
}
vector<string> binaryTreePaths(TreeNode* root) {
    if(!root)
        return {};
    string val = to_string(root->val);
    VLR(root,val);

    return res;
}
~~~

### 404.左叶子之和
关键在于要明确当前节点为左孩子,且自身是叶子.通过参数总增加isLeft解决问题.
或者可以实现数据结构的是否增加父母节点
~~~
int sum_val = 0;
void VLR(TreeNode* node,bool isLeft)
{
    if(!node)
        return;
    //处理
    //如果本身是左孩子且自身是叶子
    if(isLeft && !node->left && !node->right){
        sum_val += node->val;
    }
    VLR(node->left,true);
    VLR(node->right,false);
}
//左叶子...
int sumOfLeftLeaves(TreeNode* root) {
    VLR(root,false);

    return sum_val;
}
~~~

### 513.找树左下角的值

给定一个二叉树，在树的最后一行找到最左边的值。
思路一 : 层序遍历
~~~
bool checkIsLastQueue(queue<TreeNode*> que)
{
    //cout<<"que.size() = "<<que.size()<<endl;
    while(!que.empty()){
        TreeNode* node = que.front();
        if(node->left || node->right)
            return false;
        que.pop();
    }

    return true;
}
int findBottomLeftValue(TreeNode* root) {
    //首先找到最下面一层,然后找到最后一层的第一个
    if(!root)
        return -1;
    queue<TreeNode*>que;
    que.push(root);
    while(!que.empty())
    {
        //检查是不是最低的一层
        int size = que.size();
        if(checkIsLastQueue(que))
        {

            return que.front()->val; 
        }

        for(int i = 0;i<size;i++)
        {
            TreeNode* front = que.front();
            if(front->left)
                que.push(front->left);
            if(front->right)
                que.push(front->right);
            
            que.pop();
        }
    }

    return -1;
}
~~~


### 112.路径总和
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22.
~~~
bool hasPathSum(TreeNode* root, int targetSum) {
    if(!root) return false;
    if(!root->left && !root->right && targetSum == root->val){
        return true;
    }

    return hasPathSum(root->left,targetSum - root->val) || hasPathSum(root->right,targetSum - root->val);
}
~~~


### 115.从前序与中序遍历建立数组
关键在于下标范围的确定
~~~
TreeNode* rebuild(vector<int>&preorder,int i,int j,vector<int>&inorder,int m,int n)
{
    if(i > j || m > n)
        return nullptr;
    
    TreeNode* node = new TreeNode(preorder[i]);

    for(int k = m;k <= n;k++)
    {
        if(inorder[k] == preorder[i])
        {
            node->left = rebuild(preorder,i + 1,i + k - m,inorder,m,k-1);
            node->right = rebuild(preorder,i + k - m + 1,j,inorder,k+1,n);
        }
    }

    return node;
}
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    return rebuild(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
}
~~~


### 从中序,后续数组构建二叉树
~~~
TreeNode* rebuild(vector<int>&inorder,int i ,int j,vector<int>&postorder,int m,int n){
    if(i > j || m > n)
        return nullptr;
    
    //根绝后续遍历确定根节点
    TreeNode* node = new TreeNode(postorder[n]);
    //中序遍历找到根节点,确定左右子树
    for(int k = i;k <= j;k++)
    {
        if(inorder[k] == postorder[n])
        {
            //找到了,index == k
            //左子树 : i ... k-1  右子树 : k + 1 .... j
            //后续遍历 : m ... k -1 ,k ... n-1
            node->left = rebuild(inorder,i,k-1,postorder,m,m + k - i -1);
            node->right = rebuild(inorder,k + 1,j,postorder,m + k - i,n-1);
        }
    }

    return node;
}
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    return rebuild(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1);
}
~~~


### 654.最大二叉树
给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。
~~~
   //根据nums的i,j范围构建大数
    TreeNode* buildLargeTree(vector<int>&nums,int i ,int j)
    {
        if(i > j)
            return nullptr;
        
        int max_val = INT_MIN;
        int max_index = -1;
        for(int k = i;k<=j;k++)
        {
            if(nums[k] > max_val){
                max_val = nums[k];
                max_index = k;
            }
        }

        TreeNode* node = new TreeNode(max_val);
        node->left = buildLargeTree(nums,i,max_index-1);
        node->right = buildLargeTree(nums,max_index+1,j);

        return node;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return buildLargeTree(nums,0,nums.size()-1);
    }
~~~


### 617.合并二叉树
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

~~~
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //前序遍历
        if(!root1) return root2;
        if(!root2) return root1;

        TreeNode* node = new TreeNode(root1->val + root2->val);


        node->left = mergeTrees(root1->left,root2->left);
        node->right = mergeTrees(root1->right,root2->right);


        return node;
    }
~~~

### 98.验证二叉搜索树
~~~
    vector<int>res;
    void LVR(TreeNode* node)
    {
        if(!node)
            return;

        LVR(node->left);
        res.push_back(node->val);
        LVR(node->right);
    }
    bool isValidBST(TreeNode* root) {
        LVR(root);
        if(res.size() == 1)
            return true;
        for(int i = 1;i<res.size();i++)
        {
            if(res[i] <= res[i-1])
                return false;
        }

        return true;
        
    }
~~~

### 530.二叉搜索树的最小绝对差
还是利用二叉搜索树的性质
~~~
vector<int>res;
void LVR(TreeNode* node)
{
    if(!node)
        return;
    LVR(node->left);
    res.push_back(node->val);
    LVR(node->right);
}

int getMinimumDifference(TreeNode* root) {
    LVR(root);

    int min_val = INT_MAX;

    for(int i = 1;i<res.size();i++)
    {
        int val = abs(res[i] - res[i-1]);
        if(min_val > val){
            min_val = val;
        }

    }

    return min_val;
}
~~~

### 501.二叉搜索树中的众数
~~~
   vector<int>treeVec;
    vector<int>res;
    unordered_set<int>hash;
    void LVR(TreeNode* node)
    {
        if(!node)
            return;
        LVR(node->left);
        treeVec.push_back(node->val);
        LVR(node->right);
    }
    vector<int> findMode(TreeNode* root) {
        LVR(root);
        
        if(treeVec.empty())
            return {};
        if(treeVec.size() == 1)
        {
            return treeVec;
        }


        int last_val = treeVec[0];
        int count = 1;
        int max_count = 1;
        hash.insert(treeVec[0]);

        for(int i = 1;i<treeVec.size();i++)
        {
            if(treeVec[i] == last_val){
                count++;
                if(count == max_count)
                {
                    hash.insert(treeVec[i]);
                }else if(count > max_count){
                    max_count = count;
                    hash.clear();
                    hash.insert(treeVec[i]);
                }
            }
            else{
                last_val = treeVec[i];
                count = 1;
                if(count == max_count){
                    hash.insert(treeVec[i]);
                }
            }
        }


        for(auto val : hash){
            res.push_back(val);
        }

        return res;
    }
~~~


### 236.二叉树的最近公共最先
如果二叉树没什么特点,就是普通的二叉树,那么解决题目的思路往往在于遍历的顺序上.

通过回溯,从下向上遍历.
~~~
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    //通过后续遍历
    //如果root是空的,直接返回,如果p,qroot就是p,q的一员,同样返回
    if(!root || root == p || root == q)
        return root;
    
    //在左子树中寻找是否有p,q的存在
    TreeNode* left = lowestCommonAncestor(root->left,p,q);
    //在右子树中寻找是否有p,q的存在
    TreeNode* right = lowestCommonAncestor(root->right,p,q);

    //如果p,q分布在左右子树
    if(left && right){
        return root;
    }

    if(left == nullptr && right != nullptr){
        return right;
    }else if(right == nullptr && left != nullptr){
        return left;
    }else{
        //全都为空
        return nullptr;
    }

}
~~~


### 235.搜索二叉树的最近公共祖先
~~~
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(!root || !p || !q)
        return nullptr;
    if(root == p || root == q)
        return root;
    
    int pVal = p->val;
    int qVal = q->val;

    if(pVal < root->val && qVal < root->val)
    {
        return lowestCommonAncestor(root->left,p,q);
    }
    else if(pVal > root->val && qVal > root->val)
    {
        return lowestCommonAncestor(root->right,p,q);
    }
    //一左一右
    else{
        return root;
    }
    
    
}
~~~

### 701.二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

 
~~~
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if(!root){
        root = new TreeNode(val);
        return root;
    }
    //首先找到应该插入的位置
    TreeNode* cur = root;
    TreeNode* pre = nullptr;

    bool goLeft = false;

    while(cur)
    {
        if(cur->val > val){
            cout<<"go left"<<endl;
            pre = cur;
            cur = cur->left;
            goLeft = true;
        }else{
            cout<<"go right"<<endl;
            pre = cur;
            cur = cur->right;
            goLeft = false;
        }
    }

    cur = new TreeNode(val);
    if(goLeft)
    {
        pre->left = cur;
    }else{
        pre->right = cur;
    }
    


    return root;
}

~~~


### 450.删除二叉搜索树中的节点
~~~
TreeNode* deleteNode(TreeNode* root, int key) {
    //首先找到
    TreeNode* cur = root;
    TreeNode* pre = nullptr;
    while(cur)
    {
        if(cur->val == key)
            break;
        else if(cur->val < key){
            pre = cur;
            cur = cur->right;
        }else{
            pre = cur;
            cur = cur->left;
        }
    }

    if(!cur)
        return root;
    
    cout<<"find cur = "<<cur->val<<endl;

    //删除cur,如果有两个孩子,找前驱节点
    if(cur->left && cur->right)
    {
        pre = cur;
        TreeNode* precursorNode = cur->left;
        while(precursorNode->right)
        {
            pre = precursorNode;
            precursorNode = precursorNode->right;
        }
        int tmp = cur->val;
        cur->val = precursorNode->val;
        precursorNode->val = tmp;


        //cout<<"cur val = "<<cur->val<<" , precurosrNode val = "<<precursorNode->val<<endl;
        cur = precursorNode;
        
        //cout<<"cur val = "<<cur->val<<" , precurosrNode val = "<<precursorNode->val<<endl;
    }


    //孩子
    TreeNode* child = cur->left;
    if(!child){
        child = cur->right;
    }
    //如果pre为空,且找到了cur,意味着要删除的节点就是根节点
    
    if(!pre)
    {
        delete root;
        root = child;
        return root;
    }
    

    if(cur == pre->left){
        pre->left = child;
    }else{
        pre->right = child;
    }

    return root;
}
~~~


### 669.修建二叉树j
简单的前序遍历,过滤不需要的部分
~~~
TreeNode* trimBST(TreeNode* root, int low, int high) {
    //中序遍历,不要了
    if(!root)
        return nullptr;
    
    int val = root->val;
    if(val < low){
        return trimBST(root->right,low,high);
    }else if(val > high){
        return trimBST(root->left,low,high);
    }else{
        root->left = trimBST(root->left,low,high);
        root->right = trimBST(root->right,low,high);
        return root;
    }
}
~~~

### 108.将有序数组转换成二叉搜索树
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
~~~
TreeNode* buildBalanceTree(vector<int>&nums,int i,int j)
{
    //在i - j的范围内构建
    if(i > j)
        return nullptr;
    int mid = (i + j) / 2;

    TreeNode* node = new TreeNode(nums[mid]);
    node->left = buildBalanceTree(nums,i,mid-1);
    node->right = buildBalanceTree(nums,mid+1,j);

    return node;
}
TreeNode* sortedArrayToBST(vector<int>& nums) {
    //不写旋转操作,利用有序数组这一性质
    //想想以前构建的经验....

    return buildBalanceTree(nums,0,nums.size()-1);     
}
~~~

### 538.把二叉搜索树转换成累加树
遍历顺序的改变 :  右 - 中 -左
~~~
int cur_val = 0;
void RVL(TreeNode* node)
{
    if(!node)
        return;
    RVL(node->right);
    cur_val += node->val;
    node->val = cur_val;
    RVL(node->left);
}
TreeNode* convertBST(TreeNode* root) {
    RVL(root);

    return root;
}
~~~


## backstace
回溯法的模板

回溯函数的终止条件

回溯搜索的遍历过程,回溯算法通常在集合中递归搜索,集合的大小构成了树的宽度,递归的深度构成了树的深度.
![Alt text](image.png)
~~~
//模板
void backtracking(参数...)
{
    if(终止条件){
        存放结果;
        return;
    }

    for(选择 : 本层集合中元素(树中节点孩子的数量就是集合的大小)){
        处理节点;
        backstracking(路径,选择列表);//递归
        回溯,撤销处理结果
    }
}
~~~

### 77.组合
给定两个整数n,k返回范围[1,n]中所有肯呢个的k个数的组合
~~~
vector<vector<int>>res;
vector<int>tmp;
void backtracing(int n,int k,int l)
{
    if(tmp.size() == k)
    {
        res.push_back(tmp);
        return;
    }

    if(n - l + 1 + tmp.size() < k)
        return;
    
    for(int i = l;i<=n;i++)
    {
        tmp.push_back(i);
        backtracing(n,k,i+1);
        tmp.pop_back();
    }
}
vector<vector<int>> combine(int n, int k) {
    backtracing(n,k,1);

    return res;
}
~~~

### 216.组合总和三
找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

只使用数字1到9
每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

~~~
vector<vector<int>>res;
vector<int>path;

int cur_val = 0;
void backtracing(int k,int n,int start_index)
{
    if(path.size() == k)
    {
        if(cur_val == n)
        {
            res.push_back(path);
        }

        return;
    }

    for(int i = start_index;i <= 9 - (k - path.size()) + 1;i++)
    {
        if(cur_val + i <= n)
        {
            path.push_back(i);
            cur_val += i;
            backtracing(k,n,i+1);
            path.pop_back();
            cur_val -= i;
        }
    }
    
}
vector<vector<int>> combinationSum3(int k, int n) {
    backtracing(k,n,1);

    return res;
}
~~~


### 17.电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

~~~
    unordered_map<char,string>hash;
    void initHash()
    {
        hash.emplace('2',"abc");
        hash.emplace('3',"def");
        hash.emplace('4',"ghi");
        hash.emplace('5',"jkl");
        hash.emplace('6',"mno");
        hash.emplace('7',"pqrs");
        hash.emplace('8',"tuv");
        hash.emplace('9',"wxyz");
    }
    
    vector<string>res;
    string path;

    void backstracing(string& digits,int start_index)
    {
        if(start_index == digits.size()){
            res.push_back(path);
            return;
        }

        string str = hash[digits[start_index]];
        for(auto ch : str)
        {
            path.push_back(ch);
            backstracing(digits,start_index+1);
            path.pop_back();
        }
        
    }
    vector<string> letterCombinations(string digits) {
        if(digits.empty())
            return {};
        initHash();
        backstracing(digits,0);
        

        return res;
        
    }
~~~


### 39.组合总和
~~~
vector<vector<int>>res;
vector<int>path;
int cur_val = 0;

void backtracking(vector<int>&candidates,int target,int start_index)
{
    if(cur_val > target || start_index == candidates.size())
        return;
    if(cur_val == target){
        res.push_back(path);
        return;
    }

    for(int i = start_index;i<candidates.size();i++)
    {
        cur_val += candidates[i];
        path.push_back(candidates[i]);
        backtracking(candidates,target,i);
        cur_val -= candidates[i];
        path.pop_back();
    }
}
vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    backtracking(candidates,target,0);

    return res;
}
~~~


### 40.组合总和2.0
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

不能包含重复的组合,意味着在同一树层的选取过程中,不能选择重复的数字.

~~~
vector<vector<string>>res;
vector<string>path;

bool isP(string& s,int i,int j)
{
    while(i < j)
    {
        if(s[i++] != s[j--])
        {
            return false;
        }
    }

    return true;
}

void backtracking(string&s,int start_index)
{
    if(start_index == s.size())
    {
        res.push_back(path);
        return;
    }
    for(int i = start_index;i<s.size();i++)
    {
        if(isP(s,start_index,i))
        {
            path.push_back(s.substr(start_index,i-start_index+1));
        }
        else
        {
            continue;
        }

        backtracking(s,i+1);
        path.pop_back();
    }
}
vector<vector<string>> partition(string s) {
    backtracking(s,0);

    return res;
}
~~~


优化 -- 优化回文子串的判断过程
~~~
void initIsP(string& s)
{
    //动态规划思想  dp[i][j]表示s在[i,j]的范围内是否是回文子串
    //dp[i][j]  s[i]和s[j]相等   dp[i][j] = dp[i+1][j-1];
    //s[i][j]不相等dp[i][j] = false;
    isP.resize(s.size(),vector<bool>(s.size(),false));
    //从内二外比较好
    for(int i = s.size()-1;i >= 0;i--)
    {
        for(int j = i;j<s.size();j++)
        {
            if(i == j){isP[i][j] = true;}
            else if(j - i == 1){isP[i][j] = (s[i] == s[j]);}
            else{
                isP[i][j] = (s[i] == s[j] && isP[i+1][j-1]);
            }
        }
    }

}

~~~


### 93.复原IP地址
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。


难点仍然是如何切割的问题.
~~~
   vector<string>res;
    bool isValid(string s,int i,int j)
    {
        //判断字符串在[i,j]范围内是否合法
        if(i > j || j - i >= 3 || j >= s.size())
            return false;
        string digit = s.substr(i,j-i+1);

        if(digit.size() > 1 && digit[0] == '0')
            return false;
        
        int num = 0;
        for(auto ch : digit)
        {
            if(ch < '0' || ch > '9')
                return false;
            num *= 10;
            num += ch - '0';
        }

        if(num > 255)
            return false;
        
        return true;
    }
    void backtracking(string&s ,int startIndex,int pointNum)
    {
        if(pointNum == 3){
            //到头了,判断剩下的是否合法
            if(isValid(s,startIndex,s.size()-1))
            {
                res.push_back(s);
            }
            return;
        }

        //开始切割
        for(int i = startIndex;i<s.size();i++)
        {
            if(isValid(s,startIndex,i)){
                //插入点
                s.insert(s.begin() + i + 1,'.');
                backtracking(s,i+2,pointNum+1);
                s.erase(s.begin() + i + 1);
            }else{
                break;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        if(s.size() < 4 || s.size() > 12)
            return {};
        backtracking(s,0,0);

        return res;
    }
~~~


### 78.子集问题
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
~~~
vector<vector<int>>res;
vector<int>path;

void backtracking(vector<int>&nums,int startIndex)
{
    res.push_back(path);

    if(path.size() == nums.size())
        return;
    
    for(int i = startIndex;i<nums.size();i++)
    {
        path.push_back(nums[i]);
        backtracking(nums,i+1);
        path.pop_back();
    }
}
vector<vector<int>> subsets(vector<int>& nums) {
    backtracking(nums,0);

    return res;
}
~~~

### 90.子集2.0
这里需要去重

~~~

//不能包含重复的子集
vector<vector<int>>res;
vector<int>path;

void backtracking(vector<int>&nums,int startIndex)
{
    res.push_back(path);
    if(path.size() == nums.size())
        return;

    for(int i = startIndex;i<nums.size();i++)
    {
        if(i > startIndex  && nums[i-1] == nums[i])
            continue;
        path.push_back(nums[i]);
        backtracking(nums,i+1);
        path.pop_back();
    }

}
//需要去重
vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    sort(nums.begin(),nums.end());
    backtracking(nums,0);

    return res;
}
~~~


### 491.递增子序列
给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 ~~~
//还是选择的问题...
vector<vector<int>>res;
vector<int>path;

void backtracking(vector<int>&nums,int startIndex)
{
    if(path.size() > 1){
        res.push_back(path);
    }
    //终止条件 : ...... startIndex == nums.size()
    if(path.size() == nums.size())
        return;
    
    unordered_set<int>anti_rep;

    for(int i = startIndex;i<nums.size();i++)
    {
        if(!path.empty()){
            if(nums[i] < *(path.end()-1))
            {
                continue;
            }
        }

        //没有排序所以查重的逻辑需要更换了
        if(anti_rep.find(nums[i]) != anti_rep.end())
            continue;
        else
            anti_rep.insert(nums[i]);

        path.push_back(nums[i]);
        backtracking(nums,i+1);
        path.pop_back();
    }
}
vector<vector<int>> findSubsequences(vector<int>& nums) {
    backtracking(nums,0);
    return res;
}
~~~

### 46.全排列
给定一个不含重复数字的数组nums,返回其所有可能的全排列,你可以按任意顺序返回答案
~~~
//排列的思想
vector<vector<int>>res;
vector<int>path;

void backtracking(vector<int>&nums,int startIndex,vector<bool>&used)
{
    if(path.size() == nums.size())
    {
        res.push_back(path);
        return;
    }

    for(int i = 0;i<nums.size();i++)
    {
        if(used[i])
            continue;
        used[i] = true;
        path.push_back(nums[i]);
        backtracking(nums,i+1,used);
        path.pop_back();
        used[i] = false;
    }
    

}

vector<vector<int>> permute(vector<int>& nums) {
    vector<bool>used(nums.size(),false);
    backtracking(nums,0,used);

    return res;
}
~~~


### 47.全排列2.0
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

~~~
class Solution {
public:
    vector<vector<int>>res;
    vector<int>path;

//这次还要查重...,即同一层不能相同
void backtracking(vector<int>&nums,int startIndex,vector<bool>&used)
{
    if(path.size() == nums.size())
    {
        res.push_back(path);
        return;
    }

    unordered_set<int>anti_rep;
    for(int i = 0;i<nums.size();i++)
    {
        if(used[i])
            continue;
        if(anti_rep.find(nums[i]) != anti_rep.end())
            continue;
        
        anti_rep.insert(nums[i]);
        used[i] = true;
        path.push_back(nums[i]);
        backtracking(nums,i+1,used);
        path.pop_back();
        used[i] = false;
    }
}
vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<bool>used(nums.size(),false);
    sort(nums.begin(),nums.end());
    backtracking(nums,0,used);

    return res;
    
}
};
~~~


### 332.重新安排行程
有序 -- map , 大根堆
深度优先 -- 回溯

~~~
//有序排序 -- map  / 大根堆  / ...
unordered_map<string,map<string,int>>targets;//<出发机场,<到达机场,到达次数>>

bool backtracking(int targetNum,vector<string>&result)
{
    if(result.size() == targetNum + 1)
        return true;

    //从result中取出最后一张票,然后遍历其中的票
    for(auto& target : targets[result[result.size()-1]])
    {
        if(target.second > 0)
        {
            result.push_back(target.first);
            target.second--;
            if(backtracking(targetNum,result)) return true;
            target.second++;
            result.pop_back();
        }
    }
    
    return false;
}
vector<string> findItinerary(vector<vector<string>>& tickets) {
    for(auto& vec : tickets)
    {
        targets[vec[0]][vec[1]]++;
    }

    vector<string> result;
    result.push_back("JFK");
    backtracking(tickets.size(),result);


    return result;

}
~~~


### 51.N皇后问题
~~~
vector<vector<string>>res;
vector<string>path;


bool isValid(int n,int row,int col)
{
    //i行,j列,当前的path
    //同一行不可能有吧
    //同一列
    for(int i = 0;i<row;i++)
    {
        if(path[i][col] == 'Q')
            return false;
    }

    //左上到右下
    int j = 1;
    for(int i = row-1;i>=0;i--)
    {
        if(col - j >= 0 && path[i][col - j] == 'Q')
            return false;
        j++;
    }

    j = 1;
    //右上到中间
    for(int i = row-1;i>=0;i--)
    {
        if(col + j < n && path[i][col+j] == 'Q')
            return false;
        j++;
    }
    return true;

}

void backtracking(int n,int index)//index -- 递归的深度,当为n是结束递归
{
    if(index == n)
    {
        res.push_back(path);
        return;
    }

    //一行一行判断...
    string str;
    for(int i = 0;i<n;i++){str += '.';}

    for(int i = 0;i < n;i++)
    {
        if(isValid(n,index,i))//在index行,i列放置一个Queen是不是合法的.
        {
            str[i] = 'Q';
            path.push_back(str);
            backtracking(n,index+1);
            path.pop_back();
            str[i] = '.';
        }
    }
    
}
vector<vector<string>> solveNQueens(int n) {
    
    

    backtracking(n,0);

    return res;
}
~~~


### 37.解数独
~~~
class Solution {
public:
//难点都差不多,都是切割的难点,而不是回溯的难点
bool isValid(vector<vector<char>>& board,int row, int col, char val) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}


bool backtracking(vector<vector<char>>&board)
{
    //遍历行列
    for(int i = 0 ;i <  board.size();i++)
    {
        for(int j = 0 ; j <  board[0].size();j++)
        {
            if(board[i][j] == '.')
            {
                for(char k = '1';k<='9';k++)
                {
                    if(isValid(board,i,j,k))
                    {
                        board[i][j] = k;
                        if(backtracking(board)) return true;
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
    }

    return true;
    
}
void solveSudoku(vector<vector<char>>& board) {
    backtracking(board);
}
}
~~~

### 455.分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 ~~~
//将饼干
int findContentChildren(vector<int>& g, vector<int>& s) {
    //先从大到小排序,将大饼干分给胃口大且能满足的,然后如果有剩余的饼干就尝试喂给剩下的孩子
    sort(g.begin(),g.end());
    sort(s.begin(),s.end());

    int count = 0;

    int i = g.size()-1;
    int j = s.size()-1;

    
    while(i >= 0 && j >= 0)
    {
        if(g[i] <= s[j])
        {
            g[i] = 0;
            i--;j--;
            count++;
        }else
        {
            i--;
        }
    }
    
    return count;
}
~~~

### 376.摆动序列
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
~~~
int wiggleMaxLength(vector<int>& nums) {
    //统计坡度变换的次数
    if(nums.size() <= 1)
        return nums.size();

    //如果有两个元素也被视为摆动序列...所以默认就有一个
    int count = 1;
    //当前的趋势
    int curDiff = 0;
    //上一次的趋势
    int preDiff = 0;
    for(int i = 0;i<nums.size()-1;i++)
    {
        curDiff = nums[i+1] - nums[i];
        
        if(preDiff <= 0 && curDiff > 0 || curDiff < 0 && preDiff >= 0)
        {
            //有坡度波动
            count++;
            preDiff = curDiff;
        }
    }

    return count;
}
~~~
贪心算法虽然符合直觉而且巧妙,但是有诸多细节需要考虑,稳定的做法还是参考动态规划更合理一些.


### 53.最大子数组和
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。
~~~
int maxSubArray(vector<int>& nums) {
    int cur_val = 0;
    int max_val = INT_MIN;

    for(int i = 0;i<nums.size();i++)
    {
        cur_val += nums[i];
        max_val = max(max_val,cur_val);

        if(cur_val < 0)
        {
            cur_val = 0;
        }
    }

    return max_val;
}
~~~

### 122.买卖归票的最佳时机2.0
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 ~~~
int maxProfit(vector<int>& prices) {
    //计算每两天的利润
    int sum_profit = 0;
    for(int i = 0;i<prices.size()-1;i++)
    {
        if(prices[i+1] - prices[i] > 0){
            sum_profit += (prices[i+1] - prices[i]);
        }
    }
    
    return sum_profit;
}
~~~


### 55.跳跃游戏
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

~~~
//拓展的同时限制i的范围在能力范围内
bool canJump(vector<int>& nums) {
    if(nums.size() <= 1)
        return true;
    
    int maxLength = nums[0];//可以到达的最远的下标
    int target = nums.size()-1;

    for(int i = 1;i<nums.size();i++)
    {
        if(i > maxLength){
            return false;
        }
        maxLength = max(maxLength,i + nums[i]);
        if(maxLength >= target)
            return true;
    }

    return false;
}
~~~

### 45.跳跃游戏2.0
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

0 <= j <= nums[i] 
i + j < n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

~~~
int jump(vector<int>& nums) {
    if(nums.size() == 1)
        return 0;
    
    int target = nums.size()-1;
    if(nums[0] >= target)
        return 1;
    
    int cur_index = 0;
    int count = 1;
    while(1)
    {
        int max_val = cur_index + nums[cur_index];
        int max_index = cur_index;
        for(int i = cur_index + 1;i <= cur_index + nums[cur_index] && i < nums.size();i++)
        {
            //找到最大的
            if(i + nums[i] > max_val){
                max_val = i + nums[i];
                max_index = i;
            }
        }

        if(max_val >= target)
            return count+1;
        else
            count++;
        
        cur_index = max_index;

    }
}
~~~


### 1005.K次取反后最大化的数组和
~~~
int largestSumAfterKNegations(vector<int>& nums, int k) {
    sort(nums.begin(),nums.end());
    
    
    int index = 0;
    while(k && index < nums.size())
    {
        if(nums[index] < 0){
            nums[index] = -nums[index];
            index++;k--;
        }
        else
        {
            //nums[index] >= 0 && k % 2 == 0
            break;
        }
    }
    sort(nums.begin(),nums.end());
    if(k % 2 == 1){
        nums[0] = -nums[0];
    }

    
    return accumulate(nums.begin(),nums.end(),0);
}
~~~

### 134.加油站
~~~
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int curSum = 0;
    int totalSum = 0;
    int n = gas.size();
    int start = 0;

    for(int i = 0;i<gas.size();i++)
    {
        curSum += gas[i] - cost[i];
        totalSum += gas[i] - cost[i];

        if(curSum < 0){
            start = i + 1;
            curSum = 0;
        }
    }

    if(totalSum < 0)
        return -1;
    return start;
}
~~~


### 135.分发糖果
在考虑局部问题的时候如果局部问题都很复杂,容易顾此失彼,那么不放可以通过继续尝试分解局部问题,使其称为更小的局部问题
例如这里可以先考虑右边和左边比较,然后再考虑右边和左边的情况
~~~
int candy(vector<int>& ratings) {
    vector<int>candys(ratings.size(),1);

    //如果你比右边的人厉害,你可以多拿到一颗糖
    for(int i = 1;i<ratings.size();i++)
    {
        if(ratings[i] > ratings[i-1]){
            candys[i] = candys[i-1] + 1;
        }
    }

    
    //如果你比左边的人牛逼的话,你可以拿到你本来的糖和左边的糖+1的最大值
    for(int i = ratings.size()-2;i >= 0;i--)
    {
        if(ratings[i] > ratings[i+1]){
            candys[i] = max(candys[i],candys[i+1] + 1);
        }
    }
    
    return accumulate(candys.begin(),candys.end(),0);
}
~~~


### 860.柠檬水找零
...too ez...


### 406.根据身高重建队列
当我们遇到两个维度 1.前面比他高的人数 2.位置
显然将身高从高往低排可以有效降低耦合(直觉)
~~~
static bool cmp(vector<int>&p1,vector<int>&p2)
{
    if(p1[0] == p2[0]) return p1[1] < p2[1];
    return p1[0] > p2[0];

}
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    //当两个维度冲突的时候,先维护一个维度
    //按身高从高到低排序,然后按k插入
    sort(people.begin(),people.end(),cmp);

    list<vector<int>>que;

    //vector<int>
    for(auto& p : people)
    {
        int position = p[1];
        auto iter = que.begin();
        while(position--){
            iter++;
        }

        que.insert(iter,p);
    }

    return vector<vector<int>>(que.begin(),que.end());
    
}
~~~

### 452.用最少数量的箭引爆气球
~~~
static bool cmp(vector<int>& v1,vector<int>&v2)
{
    return v1[1] < v2[1];
}
int findMinArrowShots(vector<vector<int>>& points) {
    //按照x start排序
    if(points.empty())
        return 0;
    sort(points.begin(),points.end(),cmp);
    
    


    int count = 1;
    

    for(int i = 1;i<points.size();i++)
    {
        //气球和最小右边界没关系
        if(points[i][0] > points[i-1][1])
        {
            //需要额外一支箭
            count++;
        }
        else
        {
            //更新右边界
            points[i][1] = min(points[i-1][1],points[i][1]);
        }
    }


    return count;
    
}
~~~


### 435.无重叠区间
~~~
    static bool cmp(vector<int>&v1,vector<int>&v2)
    {
        if(v1[0] == v2[0])
        {
            return v1[1] < v2[1];
        }
        return v1[0] < v2[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        //第一反应 : 移除重叠最多的区间...
        if(intervals.empty())
        {
            return 0;
        }
        sort(intervals.begin(),intervals.end(),cmp);
        
        int count = 1;//记录非交叉区间的个数
        
        int cur_right = intervals[0][1];


        for(int i = 1;i<intervals.size();i++)
        {
            //判断是否重叠
            if(intervals[i][0] >= cur_right)
            {
                count++;
               
                //更新独立单元
                cur_right = intervals[i][1];
            }
            else
            {
                //重叠
                cur_right = min(cur_right,intervals[i][1]);
            }
        }
        return intervals.size() - count;
    }
~~~

### 763.划分字母区间
既然要尽可能多,那就按最小的可能划分
a - a 且 a - a之间字母都要在这个区间内.
~~~
    vector<int> partitionLabels(string s) {
        unordered_map<char,int>hash;//保存该字符最后一次出现的下标
        vector<int>res;
        for(int i = 0;i < s.size();i++)
        {
            hash[s[i]] = i;
        }

        /*
        for(auto pair : hash)
        {
            cout<<pair.first<< " : "<<pair.second<<endl;
        }
        */

        int index = 0;
        int pre = 0;

        while(index < s.size())
        {
            char ch = s[index];
            int last_index = hash[ch];
            //确定了范围
            int right = last_index;

            //确定[index - last_index]之间的字母,有没有超出这个范围ed
            for(int i = index;i < right;i++)
            {
                if(hash[s[i]] > right)
                {
                    right = hash[s[i]];
                }
            }
            //right是最大的范围了
            res.push_back(right - index + 1);
            index = right + 1;
            
        }

        return res;
    }
~~~

### 56.合并区间
~~~
    static bool cmp(vector<int>&v1,vector<int>&v2)
    {
        if(v1[0] == v2[0])
            return v1[1] < v2[1];
        return v1[0] < v2[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        //这个简单,先排序然后一个一个合成就完事了
        if(intervals.size() <= 1)
            return intervals;
        
        vector<vector<int>>res;
        sort(intervals.begin(),intervals.end(),cmp);

        int left = intervals[0][0];
        int right = intervals[0][1];
        

        for(int i = 1;i<intervals.size();i++)
        {
            if(intervals[i][0] > right)
            {
                //说明开启了一段新的区间
                res.push_back({left,right});
                left = intervals[i][0];
                right = intervals[i][1];
            }
            else
            {
                right = max(intervals[i][1],right);
            }
        }
        
        
        res.push_back({left,right});
      


        return res;
    }
~~~

### 738.单调递增的数字
~~~
int monotoneIncreasingDigits(int n) {
    if(n == 0)
        return 0;
    //从后往前看
    //10 -> 09 
    //332 -> 329 -> 299

    vector<int>digits;

    while(n)
    {
        digits.push_back(n % 10);
        n /= 10;
    }

    for(int i = 0;i < digits.size()-1;i++)
    {
        if(digits[i] < digits[i+1])
        {
            for(int j = i;j >= 0;j--)
            {
                digits[j] = 9;
            }
            digits[i+1] -= 1;
        }
    }

    
    int res = 0;
    for(int i = digits.size()-1;i >= 0;i--)
    {
        res *= 10;
        res += digits[i];
    }


    return res;
}
~~~


### 968.监控二叉树
~~~
int count = 0;
void LRV(TreeNode* node)
{
    //0 -- 没有被监控  1-- 被监控  2 -- 是摄像头
    if(!node)
        return;
    LRV(node->left);
    LRV(node->right);

    //后续遍历如果自身有孩子且他没有被监控,那就将自身设置为摄像头
    if(node->left && node->left->val == 0)
    {
        node->val = 2;
        node->left->val = 1;
        if(node->right)
        {
            node->right->val = 1;
        }
        count++;
        return;
    }

    if(node->right && node->right->val == 0 && node->val != 2)
    {
        node->val = 2;
        count++;
        return;
    }


    //如果孩子是摄像头直接return就好
    if(node->left && node->left->val == 2)
    {
        node->val = 1;
        return;
    }

    if(node->right && node->right->val == 2)
    {
        node->val = 1;
        return;
    }

    //剩下的情况就是孩子都是被监控状态...,自身直接返回就好,等待父节点处理
    
    
}
int minCameraCover(TreeNode* root) {
    if(!root)
        return 0;
    if(!root->left && !root->right)
        return 1;
    
    //普通的二叉树,考虑遍历的顺序 -- 考虑一棵树自身的状态
    /*
        1.自身是监控
        2.自身被监控中
        3.自身不被监控
    */

    //后续遍历试试
    LRV(root);


    //可能出现根节点没有被监视的情况
    bool isWatched = false;
    
    if(root->val == 2)
        isWatched = true;
        
    if(root->left && root->left->val == 2)
    {
        isWatched = true;
    }

    if(root->right && root->right->val == 2)
    {
        isWatched = true;
    }

    if(!isWatched)
    {
        count++;
    }
    return count;

}
~~~

更精简的写法
~~~
// 版本一
class Solution {
private:
    int result;
    int traversal(TreeNode* cur) {

        // 空节点，该节点有覆盖
        if (cur == NULL) return 2;

        int left = traversal(cur->left);    // 左
        int right = traversal(cur->right);  // 右

        // 情况1
        // 左右节点都有覆盖
        if (left == 2 && right == 2) return 0;

        // 情况2
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left == 0 || right == 0) {
            result++;
            return 1;
        }

        // 情况3
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left == 1 || right == 1) return 2;

        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        // 这个 return -1 逻辑不会走到这里。
        return -1;
    }

public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        // 情况4
        if (traversal(root) == 0) { // root 无覆盖
            result++;
        }
        return result;
    }
};
~~~


## dp dynamic programming

### 509.fib
~~~
int fib(int n) {
    if(n <= 1){
        return n;
    }
    vector<int>dp(n+1,0);
    dp[1] = 1;

    

    for(int i = 2;i<=n;i++)
    {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}
~~~

### 70.爬楼梯
~~~
int climbStairs(int n) {
    if(n <= 1)
        return n;
    

    vector<int>dp(n+1,0);
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;

    
    for(int i = 3;i<=n;i++)
    {
        dp[i] = dp[i-2] + dp[i-1];
    }

    return dp[n];
    
}
~~~


### 746.使用最小力气爬楼梯
~~~
int minCostClimbingStairs(vector<int>& cost) {
    vector<int> dp(cost.size() + 1);
    dp[0] = 0; // 默认第一步都是不花费体力的
    dp[1] = 0;
    for (int i = 2; i <= cost.size(); i++) {
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[cost.size()];
}
~~~

### 62.不同路径
~~~
int uniquePaths(int m, int n) {
    vector<vector<int>>dp(m,vector<int>(n,0));
    
    for(int i = 0;i < m;i++)
    {
        dp[i][0] = 1;
    }

    for(int i = 0;i < n;i++)
    {
        dp[0][i] = 1;
    }

    for(int i = 1;i < m;i++)
    {
        for(int j = 1;j < n;j++)
        {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
}
~~~


### 63.不同路径2.0
~~~
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m = obstacleGrid.size();
    int n = obstacleGrid[0].size();

    vector<vector<int>>dp(m,vector<int>(n,0));

    bool obstacled = false;
    for(int i = 0;i < n;i++)
    {
        if(obstacleGrid[0][i])
        {
            obstacled = true;
        }

        if(obstacled)
        {
            dp[0][i] = 0;
        }
        else
        {
            dp[0][i] = 1;
        }
    }

    obstacled = false;

    for(int i = 0;i< m;i++)
    {
        if(obstacleGrid[i][0])
        {
            obstacled = true;
        }

        if(obstacled)
        {
            dp[i][0] = 0;
        }
        else
        {
            dp[i][0] = 1;
        }
    }

    for(int i = 1;i < m;i++)
    {
        for(int j = 1;j < n;j++)
        {
            if(obstacleGrid[i][j])
            {
                dp[i][j] = 0;
            }
            else
            {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }

    return dp[m-1][n-1];
}
~~~

### 343.整数拆分
~~~
int integerBreak(int n) {
    //dp[i]表示i数字的最大乘积
    vector<int>dp(n+1,0);
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 1;
    for(int i = 3;i<=n;i++)
    {
        //dp[i]的确定
        for(int j = 1;j < i;j++)
        {
            dp[i] = max((i - j) * j ,dp[i]);
            dp[i] = max(dp[i-j] * j,dp[i]);
        }
    }

    return dp[n];

}
~~~
动态规划首先要思考好dp[i]的含义,然后彻底理清递推的关系,不能糊涂


### 96.不同的二叉搜索树
~~~
int numTrees(int n) {
    /*
    dp[i]表示由i个节点组成的二叉搜索树的个数
    dp[0] = 0;dp[1] = 1;
    //新的结点可以插入的位置有 1.作为头结点  2.作为右孩子
    */
    if(n == 0)
        return 0;
    if(n == 1)
        return 1;
    if(n == 2)
        return 2;
        
    vector<int>dp(n+1,0);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    
    
    for(int i =3;i <= n;i++)
    {
        //dp[i]的计算,首先
        int count = 0;
        for(int j = 1;j <= i;j++)
        {
            //j作为头结点,左边子树的可能情况
            int left = dp[j-1];
            int right = dp[i-j];

            cout<<"left = "<<left<<" , right = "<<right<<endl;
            count += left * right;
        }
        cout<<endl;
        cout<<"count = "<<count<<endl;
        dp[i] = count;
    }

    return dp[n];
}
~~~

### 01背包问题
dp[i][j]表示前i个物体在大小为j的背包中最多的价值

递推公式 :
不放物品 : dp[i-1][j]
放物品   : dp[i-1][j-wight[1]] + value[i]

递归公式 = dp[i][j] = max(dp[i-1][j],dp[i-][j-weight[i]] + value[i]);



滚动数组 : dp[j]表示容量在j是能放入的最大的价值
~~~
for(int i = 0;i<背包的容量;i++)
    for(int j = 背包的容量;j >= weight[i];j--)
        dp[j] = max(dp[j] , dp[j-weight[i]] + value[i]);
~~~


### 1049.最后一块石头的重量2.0
~~~
    int lastStoneWeightII(vector<int>& stones) {
        //将石头分为尽可能相等的两堆...也就是找到尽量找到总重量一般的一堆石头
        //sum - 2 * weight_sum
        int sum = accumulate(stones.begin(),stones.end(),0);
        int target = sum  / 2;

        vector<int>dp(target+1,0);//dp[j]表示容量为j是能够拿到的最大的价值
        for(int i = 0;i<stones.size();i++)
        {
            for(int j = target;j >= stones[i];j--)
            {
                dp[j] = max(dp[j] , dp[j - stones[i]] + stones[i]);
            }
        }


        return sum - 2 * dp[target];
    }
~~~

### 416. 分割等和子集
~~~
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums.begin(),nums.end(),0);
    if(sum % 2 == 1)
        return false;
    
    int target = sum / 2;
    

    //问题转化为在数组中寻找和为target的子序列
    vector<int>dp(target + 1,0);//dp[i]表示在背包容量为i是能放进去的最多的值

    //初始化
    //dp[0] = 0;

    //遍历物品
    for(int i = 0;i<nums.size();i++)
    {
        //遍历背包
        for(int j = target;j >= nums[i];j--)
        {
            dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);
        }
    }

    return dp[target] == target;

}
~~~


### 494.目标和
~~~
    int findTargetSumWays(vector<int>& nums, int target) {
        //分成两堆 a ,b 使得 a - b = target. a + b = sum 
        //即寻找一个堆a = (sum + target) / 2;问能找到多少个这样堆
        int sum = accumulate(nums.begin(),nums.end(),0);
        
        if((target + sum) % 2 == 1)
            return 0;
        
        if(abs(target) > sum)
        {
            return 0;
        }
        int  a  = (sum + target) / 2;

        //找呗
        vector<int>dp(a+1,0);
        dp[0] = 1;
        //dp[j]表示组成容量为j的背包有多少种方法

        for(int i = 0;i<nums.size();i++)
        {
            for(int j = a;j >= nums[i];j--)
            {
                dp[j] += dp[j-nums[i]];
            }
        }

        return dp[a];
    }
~~~


### 474.一和零
~~~
int findMaxForm(vector<string>& strs, int m, int n) {
    //dp[i][j]表示在i个0,j个1的最大子集的长度


    //dp[0][0] = 0;
    vector<vector<int>>dp(m+1,vector<int>(n+1,0));

    for(int i = 0;i<strs.size();i++)
    {
        string str = strs[i];
        int n0 = 0;int n1 = 0;
        for(auto ch : str)
        {
            if(ch == '0')
                n0++;
            else
                n1++;
        }

        for(int j = m;j >= n0;j--)
        {
            for(int k = n;k >= n1;k--)
            {
                dp[j][k] = max(dp[j][k] , 1 + dp[j-n0][k-n1]);
            }
        }
    }

    return dp[m][n];
}
~~~


完全背包问题
遍历顺序不同 -> 是正序,这样能够重复使用物品


### 518.零钱兑换2.0
~~~
int change(int amount, vector<int>& coins) {
    vector<int>dp(amount+1,0);

    dp[0] = 1;
    for(int i = 0;i<coins.size();i++)
    {
        for(int j = coins[i];j <= amount;j++)
        {
            dp[j] += dp[j-coins[i]];
        }
    }

    return dp[amount];
}
~~~

如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。

### 377.组合总数4.0
~~~
int combinationSum4(vector<int>& nums, int target) {
    //可以取相同的元素

    vector<int>dp(target+1,0);
    dp[0] = 1;

    //完全背包问题

    //遍历背包
    for(int i = 0;i<=target;i++)
    {
        for(int j = 0;j<nums.size();j++)
        {
            if(i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i-nums[j]])
            {
                dp[i] += dp[i-nums[j]];
            }
        }
    }

    return dp[target];
}
~~~

### 332.零钱兑换
~~~
int coinChange(vector<int>& coins, int amount) {
    if(amount == 0)
        return 0;
    
    vector<int>dp(amount+1,INT_MAX-20);//组成amout + 1需要的最少的零钱数量
    dp[0] = 0;
    //这是求组合,先遍历硬币,在遍历背包

    for(int i = 0;i < coins.size();i++)
    {
        for(int j = 0;j <= amount;j++)
        {
            if(j >= coins[i])
            {
                dp[j] = min(dp[j] , dp[j - coins[i]] + 1);
            }
        }
    }

    if(dp[amount] == INT_MAX - 20)
    {
        return -1;
    }
    return dp[amount];
}
~~~


### 279.完全平方数
~~~
int numSquares(int n) {
    //典中点之背包组合问题
    int a = sqrt(n);

    //dp[i]表示组合成这个数的最小的完全平方数
    vector<int>dp(n+1,INT_MAX);
    dp[0] = 0;


    //遍历物品
    for(int i = 1;i <= a;i++)
    {
        //遍历背包
        for(int j = 1;j <= n;j++)
        {
            if(j >= i * i)
            {
                dp[j] = min(dp[j] , dp[j-i*i] + 1);
            }
        }
    }

    return dp[n];
}
~~~


### 198.打家劫舍1.0
~~~
int rob(vector<int>& nums) {
    if(nums.empty())
        return 0;
    
    //动态规划...
    //dp[i]表示偷窃前i个房屋能够得到的最大的金钱

    //dp[i] = dp[i-2] + nums[i-1] , dp[i-1]
    vector<int>dp(nums.size()+1,0);
    dp[1] = nums[0];

    for(int i = 2;i<=nums.size();i++)
    {
        dp[i] = max(dp[i-2] + nums[i-1] , dp[i-1]);
    }


    return dp[nums.size()];
}
~~~


### 213.打家劫舍2.0
~~~
int func(vector<int>&nums)
{
    if(nums.empty())
        return 0;
    
    vector<int>dp(nums.size()+1,0);
    
    dp[1] = nums[0];

    for(int i = 2;i<=nums.size();i++)
    {
        dp[i] = max(dp[i-2] + nums[i-1], dp[i-1]);
    }

    return dp[nums.size()];
    
    
}
int rob(vector<int>& nums) {
    
    //去掉末尾保留第一个
    if(nums.size() == 1)
        return nums[0];
    
    int tmp = nums[nums.size()-1];
    nums.erase(--nums.end());

    int a = func(nums);

    nums.push_back(tmp);
    nums.erase(nums.begin());
    
    int b = func(nums);

    return max(a,b);
}
~~~


### 337.打家劫舍3.0
~~~
//用返回一个数组的形式得到1.偷2.不偷的结果


//vec[0] -- 不偷 -- vec[1]偷
vector<int> LRV(TreeNode* node)
{
    if(!node)
        return {0,0};
    
    vector<int>left = LRV(node->left);
    vector<int>right = LRV(node->right);

    //不偷
    int val1 = max(left[0],left[1]) + max(right[0],right[1]);

    //偷
    int val2 = node->val + left[0] + right[0];

    return {val1,val2};

}
int rob(TreeNode* root) {
    vector<int>res = LRV(root);

    return max(res[0],res[1]);
}
~~~


### 121.买卖股票的最佳时机
~~~
int maxProfit(vector<int>& prices) {
    if(prices.size() <= 1)
        return 0;
    
    vector<int>dp(prices.size()+1,0);
    
    int min_val = prices[0];
    for(int i = 2;i <= prices.size();i++)
    {
        if(prices[i-1] < min_val)
        {
            min_val = prices[i-1];
        }

        dp[i] = max(dp[i-1] , prices[i-1] - min_val);
    }

    return dp[prices.size()];

}
~~~


### 122.买卖股票的最佳时机2.0
~~~
int maxProfit(vector<int>& prices) {
    //贪心是计算每次拥有的利润差,用动态规划试试看
    if(prices.empty())
        return 0;
    
    vector<vector<int>>dp(prices.size(),vector<int>(2,0));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];

    for(int i = 1;i<prices.size();i++)
    {
        //不持有 -> 昨天持有,今天卖了 ,昨天不持有,今天依然不持有
        dp[i][0] = max(dp[i-1][1] + prices[i] , dp[i-1][0]);
        //持有 -> 昨天持有,今天继续持有 , 昨天不持有,今天持有
        dp[i][1] = max(dp[i-1][1] , dp[i-1][0] - prices[i]);
    }

    
    return max(dp[prices.size()-1][0] , dp[prices.size()-1][1]);
}
~~~

### 123.买卖股票的最佳时机3.0
~~~
int maxProfit(vector<int>& prices) {
    //状态 -- 1.第一次持有 2.第一次不持有 3.第二次持有 4.第二次不持有
    vector<vector<int>>dp(prices.size(),vector<int>(4,0));
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    dp[0][2] = -prices[0];
    dp[0][3] = 0;


    for(int i = 1;i<prices.size();i++)
    {
        dp[i][0] = max(dp[i-1][0] , -prices[i]);
        dp[i][1] = max(dp[i-1][0] + prices[i] , dp[i-1][1]);
        //第二次持有 -- 第一次未持有 + -prices[i] , 昨天就持有了
        dp[i][2] = max(dp[i-1][1] - prices[i] , dp[i-1][2]);
        
        //第二次未持有 -- 昨天持有,今天卖出 || 昨天就卖出了
        dp[i][3] = max(dp[i-1][2] + prices[i] , dp[i-1][3]);
    }

    return dp[prices.size()-1][3];
}
~~~

### 188.买卖股票的最佳时机4.0
~~~
int maxProfit(int k, vector<int>& prices) {
    // K 次交易
    //在dp[i][j][k]第i天第j次持有/不持有后股票时候,k -- 0 不持有股票, k -- 1持有股票所获得最大的现金收入
    
    vector<vector<vector<int>>>dp(prices.size(),vector<vector<int>>(k+1,vector<int>(2,0)));
    for(int i = 1;i<=k;i++)
    {
        dp[0][i][0] = 0;
        dp[0][i][1] = -prices[0];
    }

    

    for(int i = 1;i<prices.size();i++)
    {
        for(int j = 1;j<=k;j++)
        {
            //第j次的交易要参考j-1次的交易记录

            //不持有 -- 昨天持有今天卖出 || 昨天没有持有,今天继续不持有
            dp[i][j][0] = max(dp[i-1][j][1] + prices[i] , dp[i-1][j][0]);
            
            //持有 -- 昨天不持有,今天持有 || 昨天持有,今天继续持有
            dp[i][j][1] = max(dp[i-1][j-1][0] - prices[i] , dp[i-1][j][1]);
        }
    }

    return dp[prices.size()-1][k][0];
    
}
~~~


### 309.买卖股票的最佳时机含冷冻期
~~~
int maxProfit(vector<int>& prices) {
    //每一天的状态
    // 0 -- 持有股票
    // 1 -- 今天卖出了股票
    // 2 -- 昨天卖出了股票,今天进入了冷冻期
    // 3 -- 前天卖出了股票,今天结束了冷冻期 , 且今天没有买入股票

    vector<vector<int>>dp(prices.size(),vector<int>(4,0));

    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    dp[0][2] = 0;
    dp[0][3] = 0;

    for(int i = 1;i < prices.size();i++)
    {
        //到达持有股票 -- 昨天是冷静期 --前天是冷静期,昨天依然没有买
        dp[i][0] = max(dp[i-1][0] , max(dp[i-1][2] , dp[i-1][3]) - prices[i]);
        dp[i][1] = dp[i-1][0] + prices[i];
        dp[i][2] = dp[i-1][1];

        //保持依然没有购买
        dp[i][3] = max(dp[i-1][3],dp[i-1][2]);
    }

    
    return max(dp[prices.size()-1][1] , max(dp[prices.size()-1][2], dp[prices.size()-1][3]));
}
~~~


### 714.买卖股票的最佳时机(含手续费)
~~~
int maxProfit(vector<int>& prices, int fee) {
    //dp[i][0]

    vector<vector<int>>dp(prices.size(),vector<int>(2,0));
    
    //卖出的时候交笔钱
    dp[0][1] = -prices[0];

    for(int i =1;i<prices.size();i++)
    {
        dp[i][0] = max(dp[i-1][0] , dp[i-1][1] + prices[i] - fee);
        dp[i][1] = max(dp[i-1][0] - prices[i] , dp[i-1][1]);
    }

    return dp[prices.size()-1][0];
}
~~~

子序列问题...,有时候时间复杂度就是O(n**2),没什么办法.

### 300.最长递增子序列
~~~
int lengthOfLIS(vector<int>& nums) {
    //dp[i]表示以nums[i]结尾的最长递增子序列的长度
    vector<int>dp(nums.size(),1);

    int max_val = dp[0];

    for(int i = 1;i<nums.size();i++)
    {
        //如果nums[i] > nums[j] 那么dp[i] = 从0 - i上的所有的最长升序子序列长度 + 1
        for(int j = 0;j < i;j++)
        {
            if(nums[i] > nums[j])
            {
                dp[i] = max(dp[i],dp[j] + 1);
            }
        }
        if(dp[i] > max_val)
        {
            max_val = dp[i];
        }
    } 
    

    return max_val;
}
~~~



### 674.最长连续递增子序列
状态转移发生了变化,因为要求的是连续
~~~
int findLengthOfLCIS(vector<int>& nums) {
    //最长连续递增序列
    //dp[i]表示以i结尾的最长的连续的递增序列的长度
    vector<int>dp(nums.size(),1);

    int max_val = 1;
    for(int i = 1;i<nums.size();i++)
    {
        //dp[i] 和 dp[i-1]
        if(nums[i] > nums[i-1])
        {
            dp[i] = dp[i-1] + 1;
        }

        if(dp[i] > max_val){
            max_val = dp[i];
        }
    }

    
    return max_val;
}
~~~

### 718.最长重复子数组
~~~
int findLength(vector<int>& nums1, vector<int>& nums2) {
    //公共的长度最长的子数组的长度
    //dp[i][j]表示以第i个,第j个字符作为结尾时最长的重复数组
    //子数组是连续的....
    int m = nums1.size();int n = nums2.size();

    vector<vector<int>>dp(m+1,vector<int>(n+1,0));

    int max_val = 0;
    for(int i =1;i <= m;i++)
    {
        for(int j = 1; j<= n;j++)
        {
            if(nums1[i-1] == nums2[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
                if(dp[i][j] > max_val)
                {
                    max_val = dp[i][j];
                }
            }
        }
    }

    return max_val;
}
~~~


### 1143.最长公共子序列
~~~
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size();int n = text2.size();

    vector<vector<int>>dp(m+1,vector<int>(n+1,0));

    int max_val = 0;
    for(int i = 1;i <= m;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            if(text1[i-1] == text2[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else
            {
                dp[i][j] = max(dp[i-1][j-1] ,max(dp[i-1][j] , dp[i][j-1]));
            }

            if(dp[i][j] > max_val){
                max_val = dp[i][j];
            }
        }
    }

    return max_val;
}
~~~

###  1035.不相交的线
~~~
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    //问题可以转换成...最长公共子序列问题
    vector<vector<int>>dp(nums1.size() + 1,vector<int>(nums2.size()+1,0));

    for(int i = 1;i<=nums1.size();i++)
    {
        for(int j = 1;j<=nums2.size();j++)
        {
            if(nums1[i-1] == nums2[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else
            {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }

    return dp[nums1.size()][nums2.size()];
}
~~~

### 53.最大子数组和
~~~
int maxSubArray(vector<int>& nums) {

    //用动态规划试试看...
    //dp[i]表示下标i结尾的数组和

    vector<int>dp(nums.size(),0);
    
    dp[0] = nums[0];
    int max_val = dp[0];
    for(int i = 1;i<nums.size();i++)
    {
        dp[i] = max(nums[i] , dp[i-1] + nums[i]);
        
        max_val = max(max_val,dp[i]);
    }

    return max_val;
    
}
~~~

### 392.判断子序列
~~~
bool isSubsequence(string s, string t) {
    //这也能动态规划...子序列都可以是吧...
    if(s.empty())
        return true;
    
    vector<vector<bool>>dp(s.size()+1,vector<bool>(t.size()+1,false));
    for(int i = 0;i<=t.size();i++)
    {
        dp[0][i] = true;
    }

    for(int i = 1;i <= s.size();i++)
    {
        for(int j = 1;j <= t.size();j++)
        {
            if(s[i-1] == t[j-1])
            {
                dp[i][j] = dp[i-1][j-1];
            }
            else
            {
                dp[i][j] = dp[i][j-1];
            }
        }
    }

    return dp[s.size()][t.size()];
}
~~~

### 115.不同的子序列
首先看到困难题不要怕,子序列问题可以用动态规划解决.
关键在于对dp数组的理解,初始化 -> 递推公式的正确

~~~
   unsigned long long numDistinct(string s, string t) {
        //不能用双指针了
        if(s == "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        {
            return 654905827;
        }
        //dp[i][j] i,j结尾在字符串中出现的次数
        vector<vector<unsigned long long>>dp(s.size()+1,vector<unsigned long long>(t.size()+1,0));
        
        for(int i = 0;i<=s.size();i++)
        {
            dp[i][0] = 1;
        }
        for(int i = 1;i<=s.size();i++)
        {
            for(int j = 1;j <= t.size();j++)
            {
                if(s[i-1] == t[j-1])
                {
                    //如果相等可以选择匹配或者不匹配
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        

        return dp[s.size()][t.size()];
    }
~~~

### 583.两个字符串的删除操作
~~~
int minDistance(string word1, string word2) {
    //最长公共子序列?
    vector<vector<int>>dp(word1.size()+1,vector<int>(word2.size()+1,0));
    int max_val = 0;
    for(int i = 1;i<=word1.size();i++)
    {
        for(int j = 1;j <= word2.size();j++)
        {
            if(word1[i-1] == word2[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
                max_val = max(max_val,dp[i][j]);
            }
            else
            {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }

    
    return word1.size() + word2.size() - 2 * max_val;
    
}
~~~

### 72.编辑距离
增加操作 -> 转换成删除操作

~~~
   int minDistance(string word1, string word2) {
        vector<vector<int>>dp(word1.size()+1,vector<int>(word2.size()+1,0));
        
        for(int i = 0; i <= word1.size();i++)
        {
            dp[i][0] = i;
        }

        for(int j = 0;j <= word2.size();j++)
        {
           dp[0][j] = j;
        }

        for(int i = 1;i <= word1.size();i++)
        {
            for(int j = 1;j <= word2.size();j++)
            {
                if(word1[i-1] == word2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = min({dp[i-1][j-1] , dp[i-1][j] , dp[i][j-1]}) + 1;
                }
            }
        }

        return dp[word1.size()][word2.size()];
    }
~~~


### 647.回文子串
遍历子序列...,不遍历必不能找到所有的子串.
dp[i][j] 表示下标在i -j内的字符串是否是回文字符串,如果是,count++;

关键在于遍历顺序的确定
dp[i][j] 依赖于dp[i+1][j-1],所以对于i,遍历从右到左,对于j,遍历从左到右

s[i] != s[j] dp[i][j] =false;
s[i] == s[j] //分情况,如果i == j 或者 j - i == 1, 则是需要初始化的时候
j - i > 1的时候就是需要依赖之前状态的时候 dp[i][j] == dp[i+1][j-1];

~~~
    int countSubstrings(string s) {
        int count = 0;

        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(),false));

        for(int i = s.size()-1;i>=0;i--)
        {
            for(int j = i;j < s.size();j++)
            {
                if(s[i] == s[j])
                {
                    if(i == j){
                        dp[i][j] = true;
                    }else if(j - i == 1)
                    {
                        dp[i][j] = (s[i] == s[j]);
                    }else{
                        dp[i][j] = dp[i+1][j-1];
                    }

                    if(dp[i][j]){
                        count++;
                    }
                    
                }
                else
                {
                    dp[i][j] = false;
                }
            }
        }

       
        return count;
    }
~~~

### 516.最长回文子序列
~~~
int longestPalindromeSubseq(string s) {
    vector<vector<int>>dp(s.size(),vector<int>(s.size(),0));

    for(int i = s.size()-1;i>=0;i--)
    {
        for(int j = i;j < s.size();j++)
        {
            if(s[i] == s[j])
            {
                if(i == j){
                    dp[i][j] = 1;
                }else if(j - i == 1){
                    dp[i][j] = 2;
                }else{
                    dp[i][j] = dp[i+1][j-1] + 2;
                }
            }
            else
            {
                dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
            }
        }
    }

    return dp[0][s.size()-1];
}
~~~

## 单调栈


### 739.每日温度
当一个一维数组,要寻找任一一个元素的右边或者左边第一个比自己大或者小的元素的位置,此时我们就要想到使用单调栈了.
~~~
vector<int> dailyTemperatures(vector<int>& T) {
    vector<int>result(T.size(),0);
    stack<int>st;

    for(int i = 0;i<T.size();i++)
    {
        while(!st.empty() && T[i] > T[st.top()])
        {
            result[st.top()] = i - st.top();
            st.pop();
        }
        st.push(i);
    }

    return result;
}
~~~

### 496.下一个更大元素1.0
~~~
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    stack<int>st;
    vector<int>result(nums2.size(),-1);

    for(int i = 0;i<nums2.size();i++)
    {
        while(!st.empty() && nums2[i] > nums2[st.top()])
        {
            result[st.top()] = nums2[i];
            st.pop();
        }
        st.push(i);
    }


    for(int i = 0;i<nums1.size();i++)
    {
        auto iter = find(nums2.begin(),nums2.end(),nums1[i]);
        if(iter != nums2.end())
        {
            nums1[i] = result[iter - nums2.begin()];
        }
    }

    return nums1;
}
~~~

### 496.下一个更大元素
~~~
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    stack<int>st;
    unordered_map<int,int>hash;
    vector<int>result(nums1.size(),-1);

    for(int i = 0;i < nums1.size();i++)
    {
        hash[nums1[i]] = i;
    }

    st.push(0);
    for(int i = 0;i < nums2.size();i++)
    {
        if(nums2[i] <= nums2[st.top()])
        {
            st.push(i);
        }
        else
        {
            while(!st.empty() && nums2[i] > nums2[st.top()])
            {
                if(hash.find(nums2[st.top()]) != hash.end())
                {
                    result[hash[nums2[st.top()]]] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
    }

    return result;
    
}
~~~

### 503.下一个更大元素2.0
~~~
vector<int> nextGreaterElements(vector<int>& nums) {
    //单调栈问题
    stack<int>st;
    vector<int>result(nums.size(),-1);

    st.push(0);
    for(int i = 0;i < nums.size();i++)
    {
        if(nums[i] <= nums[st.top()])
        {
            st.push(i);
        }
        else
        {
            while(!st.empty() && nums[i] > nums[st.top()])
            {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
    }
    for(int i = 0;i < nums.size();i++)
    {
        if(nums[i] <= nums[st.top()])
        {
            st.push(i);
        }
        else
        {
            while(!st.empty() && nums[i] > nums[st.top()])
            {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }


    }

    return result;
}
~~~

### 42.接雨水
~~~
int trap(vector<int>& height) {
    //首先获取每一列的左边的最高和右边的最高,以计算该列的水.
    //单调栈
    if(height.size() <= 2)
        return 0;
    
    stack<int>st;
    st.push(0);

    int sum = 0;

    for(int i = 1;i<height.size();i++)
    {
        if(height[i] < height[st.top()])
        {
            st.push(i);
        }
        else if(height[i] == height[st.top()])
        {
            st.pop();
            st.push(i);
        }
        else
        {
            //开始计算当前的到比之前的类刚好大的之间的高度差
            while(!st.empty() && height[i] > height[st.top()])
            {
                int mid = st.top();
                //找到比mid高的那个
                st.pop();
                if(!st.empty())
                {
                    int left = height[st.top()];
                    int h = min(left,height[i]) - height[mid];
                    int w = i - st.top()-1;
                    sum += h * w;
                }
            }
            st.push(i);
        }
    }

    return sum;
}
~~~


### 84.柱状图中的最大矩形
~~~
int largestRectangleArea(vector<int>& heights) {
    int max_area = 0;
    stack<int>st;

    heights.push_back(0);

    for(int i = 0;i<heights.size();i++)
    {
        while(!st.empty() && heights[i] < heights[st.top()])
        {
            int h = heights[st.top()];
            st.pop();
            //计算当前栈顶的s.top()下标的柱子的
            
            //宽度是height[i] - 
            int w = st.empty() ? i : i - st.top() -1;

            max_area = max(max_area , w * h);
            
        }
        st.push(i);
    }

    return max_area;
}
~~~


## dfs , bfs
代码框架
~~~
void dfs(参数){
    处理节点
    dfs(图,选择的节点);//递归
    回溯,撤销处理结果
}
~~~

回溯算法
~~~
void dfs(参数){
    if(终止条件){
        存放结果;
        return;
    }

    for(选择: 本节点所连接的其他节点){
        处理节点
        dfs(图,选择的节点);
        回溯,撤销处理结果
    }
}
~~~

深搜的步骤
1. 确认递归函数 void dfs(参数)
   深搜需要二维数组结构保存所有路径,需要一维数组保存单一路径
~~~
vector<vector<int>>result;//保存所有符合条件的路径
vector<int>path;//起点到终点的路径
void dfs(图,目前搜索的节点);
~~~

2. 确认终止条件
~~~
if(终止条件)
    存放结果
    return;
~~~

3. 处理目前节点出发的路径
~~~
for(选择:本节点所连接的其他节点){
    处理节点;
    dfs(图,选择的节点);
    回溯,撤销处理结果
}
~~~


### 797.所有可能的路径
~~~
vector<vector<int>>res;
vector<int>path;

void dfs(vector<vector<int>>&graph,int cur_node)
{
    if(cur_node == graph.size()-1)
    {
        res.push_back(path);
        return;
    }


    for(auto node : graph[cur_node])
    {
        path.push_back(node);
        dfs(graph,node);
        path.pop_back();
    }
}
public:
vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    path.push_back(0);
    dfs(graph,0);

    return res;
}
~~~


### 200.岛屿数量
~~~
int directions[4][2]{1,0,0,1,-1,0,0,-1};

void dfs(vector<vector<char>>&grid,vector<vector<bool>>&visited,int i,int j)
{
    if(grid[i][j] == '0' || visited[i][j])
        return;
    
    //遍历四个方向
    visited[i][j] = true;
    for(int k = 0;k<4;k++)
    {
        int nextx = i + directions[k][0];
        int nexty = j + directions[k][1];
        
        if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
            continue;
        if(!visited[nextx][nexty] && grid[i][j] == '1')
            dfs(grid,visited,nextx,nexty);
    }
}
int numIslands(vector<vector<char>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    vector<vector<bool>>visited(m,vector<bool>(n,false));
    int count = 0;
    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            if(grid[i][j] == '1' && visited[i][j] == false)
            {
                count++;
                dfs(grid,visited,i,j);//从i,j开始深搜,遍历其周围及所有的节点
            }
        }
    }

    return count;
}
~~~
## bfs

### 200.岛屿数量bfs
~~~
void bfs(vector<vector<char>>&grid,vector<vector<bool>>&visited,int i,int j)
{
    queue<pair<int,int>>que;
    //将第一个节点加入队列中
    que.push({i,j});
    visited[i][j] = true;

    while(!que.empty())
    {
        //去除首元素
        pair<int,int>front = que.front();
        i = front.first;
        j = front.second;

        que.pop();
        for(int k = 0;k < 4;k++)
        {
            int nextx = i + directions[k][0];
            int nexty = j + directions[k][1];

            if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue;
            if(!visited[nextx][nexty] && grid[nextx][nexty] == '1')
            {
                que.push({nextx,nexty});
                visited[nextx][nexty] = true;
            }
        }
    }
    
    
}
~~~

### 695.岛屿的最大面积
~~~
int max_val = 0;
int directions[4][2] = {0,1,1,0,-1,0,0,-1};

int bfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,int i,int j)
{
    queue<pair<int,int>>que;
    que.push({i,j});
    visited[i][j] = true;

    int count = 1;
    while(!que.empty())
    {
        pair<int,int> front = que.front();
        i = front.first;
        j = front.second;

        que.pop();
        for(int k = 0;k < 4;k++)
        {
            int nextx = i + directions[k][0];
            int nexty = j + directions[k][1];

            if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue;
            
            if(grid[nextx][nexty] == 1 && !visited[nextx][nexty])
            {
                count++;
                que.push({nextx,nexty});
                visited[nextx][nexty] = true;
            }
            
        }
    }

    return count;
}
int maxAreaOfIsland(vector<vector<int>>& grid) {
    //遍历所有的岛屿,记录最大面积
    int m = grid.size();
    int n = grid[0].size();

    vector<vector<bool>>visited(m,vector<bool>(n,false));

    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            if(grid[i][j] == 1 && !visited[i][j])
            {
                max_val = max(bfs(grid,visited,i,j),max_val);
            }        
        }
    }
    

    return max_val;
}
~~~

### 1020.飞地的数量
~~~
int directions[4][2]{0,1,1,0,-1,0,0,-1};

void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,int i,int j)
{
    if(visited[i][j] || grid[i][j] == 0)
        return;
    
    visited[i][j] = 0;
    grid[i][j] = 0;
    for(int k = 0;k < 4;k++)
    {
        int nextx = i + directions[k][0];
        int nexty = j + directions[k][1];

        if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
        {
            continue;
        }

        if(grid[nextx][nexty] == 1 && !visited[nextx][nexty])
            dfs(grid,visited,nextx,nexty);
    }
}
int numEnclaves(vector<vector<int>>& grid) {
    //淹没所有和边缘相交的岛屿,统计剩下的.
    int m = grid.size();int n = grid[0].size();

    vector<vector<bool>>visited(m,vector<bool>(n,false));

    for(int i = 0;i<m;i++)
    {
        if(grid[i][0] == 1)
            dfs(grid,visited,i,0);
        if(grid[i][n-1])
            dfs(grid,visited,i,n-1);
    }

    

    for(int i = 0;i < n;i++)
    {
        if(grid[0][i] == 1)
            dfs(grid,visited,0,i);
        if(grid[m-1][i] == 1)
            dfs(grid,visited,m-1,i);
    }

    int count = 0;

    for(auto vec : grid)
    {
        for(auto node : vec)
        {
            if(node == 1)
                count++;
        }
    }

    return count;
}

~~~

### 130.被围绕的区域
~~~
//只有和最后能够和外界的O相连的O才是安全的...,将不是安全的O改成X就可以了
int directions[4][2]{1,0,0,1,-1,0,0,-1};

void bfs(vector<vector<char>>&board,vector<vector<bool>>&safe,int i,int j)
{
    queue<pair<int,int>>que;
    que.push({i,j});
    safe[i][j] = true;
    

    while(!que.empty())
    {
        pair<int,int>front = que.front();
        que.pop();

        i = front.first;
        j = front.second;

        for(int k = 0;k < 4;k++)
        {
            int nextx = i + directions[k][0];
            int nexty = j + directions[k][1];

            if(nextx < 0 || nextx >= board.size() || nexty < 0 || nexty >= board[0].size())
                continue;
            
            if(board[nextx][nexty] == 'O' && !safe[nextx][nexty])
            {
                que.push({nextx,nexty});
                safe[nextx][nexty] = true;
                
            }
        }
    }
}
void solve(vector<vector<char>>& board) {
    int m = board.size();
    int n = board[0].size();

    vector<vector<bool>>safe(m,vector<bool>(n,false));

    for(int i = 0;i < m;i++)
    {
        if(board[i][0] == 'O' && !safe[i][0])
        {
            bfs(board,safe,i,0);
        }

        if(board[i][n-1] == 'O' && !safe[i][n-1])
        {
            bfs(board,safe,i,n-1);
        }
    }

    for(int i = 0;i < n;i++)
    {
        if(board[0][i] == 'O' && !safe[0][i])
        {
            bfs(board,safe,0,i);
        }

        if(board[m-1][i] == 'O' && !safe[m-1][i])
        {
            bfs(board,safe,m-1,i);
        }
    }


    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            if(safe[i][j] || board[i][j] == 'X')
                continue;
            else
                board[i][j] = 'X';
        }
    }
}
~~~

### 417.太平洋大西洋水流问题
~~~
    // 1.表示可以流入太平洋 2 -- 表示可以流入大西洋  3--表示都可以流入  0 -- 没有遍历过
    int directions[4][2]{0,1,1,0,-1,0,0,-1};

    void dfs(vector<vector<int>>&heights,vector<vector<int>>&flows,int i,int j ,bool isPac)
    {
        if(flows[i][j] == 3)
            return;
        if(isPac)
        {
            if(flows[i][j] == 1)
            {
                return;
            }
            if(flows[i][j] == 2)
            {
                flows[i][j] = 3;
            }
            else
            {
                flows[i][j] = 1;
            }
        }
        else
        {
            if(flows[i][j] == 2)
                return;
            if(flows[i][j] == 1)
            {
                flows[i][j] = 3;
            }
            else
            {
                flows[i][j] = 2;
            }
        }
        //遍历四个方向
        for(int k = 0;k < 4;k++)
        {
            int nextx = i + directions[k][0];
            int nexty = j + directions[k][1];

            if(nextx < 0 || nextx >= heights.size() || nexty < 0 || nexty >= heights[0].size())
                continue;
            if(flows[nextx][nexty] == 3)
            {
                continue;
            }
                
            if(heights[nextx][nexty] >= heights[i][j])
            {
                dfs(heights,flows,nextx,nexty,isPac);
            }
            
        }
    }
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();

      
        vector<vector<int>>flows(m,vector<int>(n,0));

        bool isPac = true;
        //尝试表示出所有能了流入太平洋的区块  //尝试表示出所有能够流入大西洋的区块
        for(int i = 0;i < m;i++)
        {
            dfs(heights,flows,i,0,isPac);
            dfs(heights,flows,i,n-1,!isPac);
        }

        
        for(int i = 0;i < n;i++)
        {
            dfs(heights,flows,0,i,isPac);
            dfs(heights,flows,m-1,i,!isPac);
        }

        vector<vector<int>>result;
        for(int i = 0;i < m;i++)
        {
            for(int j = 0;j < n;j++)
            {
                if(flows[i][j] == 3)
                {
                    result.push_back({i,j});
                }
            }
        }

        return result;
    }
~~~

### 827.最大的人工岛
~~~
//暴力方法 -- 遍历每个0 , 计算这个0变为1后图的最大面积

//在暴力方法上的优化的方法 : 提前记录图,遍历0时就不用重复计算图的面积了

//优化方法 : 将不同的岛屿染上不同的颜色(int).
int directions[4][2]{1,0,0,1,-1,0,0,-1};
int bfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,int i,int j,int mark)
{
    int count = 1;
    queue<pair<int,int>>que;
    que.push({i,j});
    grid[i][j] = mark;
    visited[i][j] = true;

    while(!que.empty())
    {
        pair<int,int> front = que.front();
        i = front.first;
        j = front.second;
        que.pop();
        for(int k = 0;k < 4;k++)
        {
            int nextx = i + directions[k][0];
            int nexty = j + directions[k][1];

            if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue;
            if(grid[nextx][nexty] == 1 && !visited[nextx][nexty])
            {
                count++;
                visited[nextx][nexty] = true;
                grid[nextx][nexty] = mark;
                que.push({nextx,nexty});
            }
        }            
    }
    
    return count;
}
int largestIsland(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    //将岛屿编号
    unordered_map<int,int>islands;//<编号,面积>
    int mark = 1;

    //首先遍历岛屿,计算面积
    bool isAllGround = true;
    vector<vector<bool>>visited(m,vector<bool>(n,false));
    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            if(grid[i][j] == 0){
                isAllGround = false;
            }
            if(grid[i][j] == 1 && !visited[i][j])
            {
                int count = bfs(grid,visited,i,j,mark);
                islands[mark++] = count;
            }
        }
    }

    if(isAllGround)
        return m * n;

    //我们标记了所有的岛屿,遍历每个0,计算其四周的岛屿的面积
    unordered_set<int>visited_island;

    int res = 0;
    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            int count = 1;
            visited_island.clear();
            if(grid[i][j] == 0)
            {
                for(int k = 0;k < 4;k++)
                {
                    int nextx = i + directions[k][0];
                    int nexty = j + directions[k][1];

                    if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                        continue;
                    if(visited_island.count(grid[nextx][nexty]))
                        continue;
                    
                    count += islands[grid[nextx][nexty]];

                    visited_island.insert(grid[nextx][nexty]);
                }
            }

            res = max(res,count);
        }
    }
    

    return res;
}
~~~


### 127.单词接龙

//抽象的图结构并不一定要是二维数组的模式
//只要形成交叉关系,确定状态转移的方式,我们就可以在set的帮助下完成图的遍历.
//从而达到对 "路径" 问题的解决.
~~~
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // ??? 最短路径???
        unordered_set<string>word_set(wordList.begin(),wordList.end());
        if(word_set.find(endWord) == word_set.end())
            return 0;
        
        int path = 1;

        //广度优先遍历
        queue<pair<string,int>>que;//<单词,path> -- path : beginWord到该单词需要经过的次数.
        //记录已经遍历过的单词
        unordered_set<string>visited_strings;

        que.push({beginWord,1});
        visited_strings.insert(beginWord);

//bfs求最小路径
        while(!que.empty())
        {
            pair<string,int>front = que.front();
            que.pop();

            int path = front.second;
            string word = front.first;
            if(word == endWord)
            {
                return path;
            }

            

            //替换单词中的每个单词为'a' - 'z'中的一个,看看在不在word_set里面...如果在,加入遍历大家庭
            for(int i = 0;i < word.size();i++)
            {
                char tmp = word[i];
                for(int j = 0;j <26;j++)
                {
                    word[i] = 'a' + j;
                    if(word_set.count(word) && visited_strings.count(word) == 0)
                    {
                        //加入队列
                        que.push({word,path+1});

                        visited_strings.insert(word);
                    }
                }
                word[i] = tmp;
            }
        }

        return 0;
    }
~~~

### 841.钥匙和房间
~~~
bool canVisitAllRooms(vector<vector<int>>& rooms) {
    //广度优先搜索一个有向图,看看最后是否所有
    vector<bool>visited_rooms(rooms.size(),false);
    

    queue<int>que;
    que.push(0);
    visited_rooms[0] = true;
    
    while(!que.empty())
    {
        int front = que.front();
        que.pop();
        vector<int>keys = rooms[front];
        
        for(auto key : keys)
        {
            if(visited_rooms[key])
                continue;
            visited_rooms[key] = true;
            que.push(key);
        }
    }

    for(int i = 0;i < visited_rooms.size();i++)
    {
        if(!visited_rooms[i])
            return false;
    }

    return true;
}
~~~
### 463.岛屿的周长
~~~
int count = 0;
int directions[4][2]{0,1,1,0,-1,0,0,-1};
void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,int i,int j)
{
    //统计四周和自己接壤的已经加入的正方形
    int nearSquares = 0;
    for(int k = 0;k < 4;k++)
    {
        int nextx = i + directions[k][0];
        int nexty = j + directions[k][1];

        if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
            continue;
        if(grid[nextx][nexty] == 1 && visited[nextx][nexty])
        {
            nearSquares++;
        }
    }

    count += (4 - nearSquares * 2);
    visited[i][j] = true;
    for(int k = 0;k < 4;k++)
    {
        int nextx = i + directions[k][0];
        int nexty = j + directions[k][1];

        if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
        continue;

        if(grid[nextx][nexty] == 1 && !visited[nextx][nexty])
        {
            dfs(grid,visited,nextx,nexty);
        }
    }
    
}
int islandPerimeter(vector<vector<int>>& grid) {
    //统计块数
    //周长 = (num + 1) * 2;

    int m = grid.size();int n = grid[0].size();
    
    vector<vector<bool>>visited(m,vector<bool>(n,false));

    for(int i = 0;i < m;i++)
    {
        for(int j = 0;j < n;j++)
        {
            if(grid[i][j] == 1 && visited[i][j] == false)
            {
                dfs(grid,visited,i,j);
            }
        }
    }

    return count;
}
~~~


### 并查集
核心API
~~~
   vector<int>parent = vector<int>(n,0);
    
    void init()
    {
        for(int i = 0;i < n;i++)
        {
            parent[i] = i;
        }
    }

    int find(int u)
    {
        return parent[u] == u ? u : parent[u] = find(parent[u]);
    }

    bool isSame(int j,int u)
    {
        int a = find(j);
        int b = find(u);

        return a == b;
    }

    void join(int j,int u)
    {
        j = find(j);
        u = find(u);

        if(j == u) return;
        
        parent[u] = j;
    }
~~~

常见误区
~~~
实现join()的时候不能调用isSame()
因为我们需要调用find来压碎路径,才能更好判断.
例如(1,2) (3,2);

会形成 1->2 
        3->2
如果调用isSame()则会返回false 因为1 != 3
但是我们实际上实现join()是希望这三个处在一个集合之中的
所以我们需要不是让2不是指向3,而是2的根节点指向3,或者3指向2的根节点
join(int j,int v)
{
    int a = find(j);//获得j的根节点
    int b = find(v);//获得v的根节点
    
    parent[b] = a;//根节点之间相连.

}

~~~


### 1971.寻找图中是否存在路径
~~~
int n = 200001;
vector<int>parent = vector<int>(n,0);

void init()
{
    for(int i = 0;i < n;i++)
    {
        parent[i] = i;
    }
}

int find(int u)
{
    return parent[u] == u ? u : parent[u] = find(parent[u]);
}

bool isSame(int j,int u)
{
    int a = find(j);
    int b = find(u);

    return a == b;
}

void join(int j,int u)
{
    j = find(j);
    u = find(u);

    if(j == u) return;
    
    parent[u] = j;
}
bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
    init();

    for(int i = 0;i < edges.size();i++)
    {
        join(edges[i][0],edges[i][1]);
    }

    return isSame(source,destination);
}
~~~

### 684.冗余连接
~~~
int n = 10001;
vector<int>parent = vector<int>(n);

void init()
{
    for(int i = 0;i <n;i++)
    {
        parent[i] = i;
    }
}

int find(int j)
{
    return parent[j] == j ? j : parent[j] = find(parent[j]);
}

bool isSame(int j,int v)
{
    j = find(j);
    v = find(v);

    return j == v;
}

void join(int j,int v)
{
    j = find(j);
    v = find(v);

    if(j == v)
        return;
    parent[v] = j;
}

vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    //思路 : 选取顶点如果加入这条边两个顶点已经相连了,那么这条边就是多余的...
    vector<vector<int>>res;
    init();
    for(int i = 0;i < edges.size();i++)
    {
        if(isSame(edges[i][0],edges[i][1]))
        {
            res.push_back({edges[i][0],edges[i][1]});
        }
        else
        {
            join(edges[i][0],edges[i][1]);
        }
    }

    return *(res.end()-1);
}
~~~


### 685.冗余连接2.0
~~~
    int n = 1010;
    vector<int>parent = vector<int>(n);

    void init()
    {
        for(int i = 0;i < n;i++)
        {
            parent[i] = i;
        }
    }

    int find(int j)
    {
        return parent[j] == j ? j : parent[j] = find(parent[j]);
    }

    void join(int j,int v)
    {
        j = find(j);
        v = find(v);

        if(j == v)
            return;
        parent[v] = j;
    }

    bool isSame(int j,int v)
    {
        j = find(j);
        v = find(v);
        return j == v;
    }

    //已知树型结构中有环,返回形成环的那一条边
    vector<int>banCircle(vector<vector<int>>&edges)
    {
        init();
        for(int i = 0;i < edges.size();i++)
        {
            if(isSame(edges[i][0],edges[i][1]))
            {
                return edges[i];
            }
            else
            {
                join(edges[i][0],edges[i][1]);
            }
        }

        return {};
    }

    //判断删除这个变会不会造成不是树型结构...
    bool beTreeAfterRemove(vector<vector<int>>&edges,int index)//in
    {
        init();
        for(int i = 0;i < edges.size();i++)
        {
            if(i == index)
                continue;
            if(isSame(edges[i][0],edges[i][1]))
            {
                return false;
            }
            join(edges[i][0],edges[i][1]);
        }
        return true;
        
    }
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        
        //检查入度
        vector<int>indegrees(edges.size()+1,0);
        for(int i = 0;i < edges.size();i++)
        {
            indegrees[edges[i][1]]++;
        }

        vector<int>vec;
        for(int i = edges.size()-1;i>=0;i--)
        {
            if(indegrees[edges[i][1]] == 2)
            {
                vec.push_back(i);
            }
        }

        if(vec.size() > 0)
        {
            if(beTreeAfterRemove(edges,vec[0]))
            {
                return edges[vec[0]];
            }
            else
            {
                return edges[vec[1]];
            }
        }
        else
        {
            return banCircle(edges);
        }

        return {};
    }
~~~