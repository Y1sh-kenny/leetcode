# 代码随想录
~~~
计划 : 因为之前已经做过很多了,所以进度要快一些
数组 : 8 / 17  -- 8 / 17 完成
链表 : 8 / 18  -- 8 / 17 完成
哈希表 : 8 / 19 -- 8 / 18完成
字符串 : 8 / 20 
双指针 : 8 / 21
栈与队列 : 8 / 22
二叉树 : 8 / 23 - 8 / 24
回溯算法 : 8 / 25 - 8 / 26
贪心 : 8 / 27 - 8 / 28
动态规划 : 8 / 29 - 8 / 31

单调栈 和 额外题目 : 9 / 1 - 9 / 3
~~~
## Array

### 704. 二分查找...
~~~
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;int right = nums.size()-1;
        
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid-1;
            }else{
                left = mid + 1;
            }
        }
        return -1;
    }
};
~~~


### 27.移除元素
思路一 : 双指针法
~~~
class Solution {
public:
    void swap(int&a,int&b){int tmp = a;a = b;b =tmp;}
    int removeElement(vector<int>& nums, int val) {
        int left = 0;int right = nums.size() - 1;
        while(right >= 0 && left < nums.size() && left < right)
        {
            while(left < nums.size() && nums[left] != val ){
                left++;
            }

            while(right >= 0 && nums[right] == val ){
                right--;
            }

            if(left < right)
                swap(nums[left],nums[right]);
        }


        int count = 0;
        while(count < nums.size() && nums[count] != val){
            count++;
        }

        return count;
    }
};
~~~
这里是前后两个指针,有时候会用到快慢两个指针...感觉快慢指针用起来可能方便一些..
以后可以试试


### 997.有序数组的平方
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

思路1 : 还是双指针,left指向非负,right指向负
~~~
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        if(nums.empty())
        {
            return {};
        }
        vector<int>res;
        //感觉还是双指针...
        //left指向绝对值最小的负数,right指向绝对值小的非负数.
        //比较绝对值的大小...

        int left = 0,right = 0;
        //寻找第一个非负数
        while(right < nums.size() && nums[right] < 0){
            right++;
        }
        if(right == 0)//数组为空或者从第一个开始就是非负数
        {
            for(auto v : nums){
                res.push_back(pow(v,2));
            }
            return res;
        }
        else if(right == nums.size())
        {
            //数组为空或者数组全部是负数
            for(auto v : nums){
                res.push_back(pow(v,2));
            }
            //颠倒一下
            reverse(res.begin(),res.end());
            return res;
        }
        else //有正有负
        {
            left = right - 1;//left 指向绝对值最小的负数
            while(left >= 0 && right < nums.size())
            {
                if(abs(nums[left]) < abs(nums[right]))
                {
                    res.push_back(pow(nums[left--],2));
                }
                else
                {
                    res.push_back(pow(nums[right++],2));
                }
            }

            while(left >= 0){
                res.push_back(pow(nums[left--],2));
            }
            while(right < nums.size()){
                res.push_back(pow(nums[right++],2));
            }

            return res;
        }

    }
};
~~~
这样的写法繁琐了...从中间开始判断增加了很多冗余的判断,事实上我们可以从两端开始周三后.会方便很多...
~~~
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        if(nums.empty())
        {
            return {};
        }
        vector<int>res(nums.size());
        int index = nums.size() -1;
        //感觉还是双指针...
        //left指向绝对值最小的负数,right指向绝对值小的非负数.
        //比较绝对值的大小...
        //从两端开始
        int left = 0;int right = nums.size() - 1;
        
        while(left < nums.size() && right >= 0 && left <= right)
        {
            if(abs(nums[left]) < abs(nums[right])){
                res[index--] = (nums[right] * nums[right]);
                right--;
            }else{
                res[index--] = (nums[left] * nums[left]);
                left++;
            }
        }
        
        return res;

    }
};
~~~

### 209.长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

思路一 : 滑动窗口
~~~
class Solution {
public:
    //返回和 >= target的长度最小的连续子数组
    //关键词 : 连续
    //暴力 : 一次以每个元素开头,计算最小子数组的长度,返回最小值
    //滑动窗口 : 有窗口头,和窗口尾,两个状态 : 如果总长度够了 , 头 + 1, 长度不够,尾长度 + 1,且当前的窗口总行度增加
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty())
            return 0;
        if(accumulate(nums.begin(),nums.end(),0) < target)
            return 0;
        
        int left = 0, right = 0,cur_sum = 0;
        int min_len = INT_MAX;
        cur_sum = nums[left];

        while(right < nums.size())
        {
            if(cur_sum < target)
            {
                //是否有增长的能力
                if(right + 1 >= nums.size()){
                    return min_len;
                }else{
                    cur_sum += nums[++right];
                }
            }
            else // >= target
            {
                //是否是最小值
                min_len = (right - left + 1) < min_len ? (right - left + 1) : min_len;
                //尝试缩减
                cur_sum -= nums[left++];
            }
        }
        
        return min_len;
    }
};
~~~


### 59.螺旋矩阵
给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]


//状态机的思想真是让人受益...

~~~
class Solution {
public:
//经过观察,当前的正方体为n,每次填充n-1个方块,
/*
1 1 1
1 1 1
1 1 1

1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
*/
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>res(n,vector<int>(n,0));
        int dircetion = 0;//0 -- 右 1 -- 下 2 -- 左 3 -- 上
        int x = 0;
        int y = 0;
        int cur_val = 1;
        int count = n - 1;
        while(count > 0)
        {
            if(dircetion == 0){
                for(int i = 0;i<count;i++){
                    res[x][y++] = cur_val++;
                }
                dircetion = 1;
            }else if(dircetion == 1){
                for(int i = 0;i<count;i++){
                    res[x++][y] = cur_val++;
                }
                dircetion = 2;
            }else if(dircetion == 2){
                for(int i = 0;i<count;i++){
                    res[x][y--] = cur_val++;
                }
                dircetion = 3;
            }else if(dircetion == 3){
                for(int i = 0;i<count;i++){
                    res[x--][y] = cur_val++;
                }
                dircetion = 0;
                count -= 2;
                x+=1;y+=1;//base变化
            }else{
                printf("error");
                return {};
            }
        }

        if(count == 0)//n为奇数填充中间
        {
            res[n/2][n/2] = pow(n,2);
        }
        return res;
    }
};

~~~



### 35.搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

~~~
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        //典中典值二分查找
        int left = 0;int right = nums.size() - 1;

        while(left < right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        
        //left == right
        if(nums[left] >= target)
            return left;
        else
            return left + 1;
        
    }
};
~~~



## List
最简单的一集,小时候写链表笑出声了...

### 203.移除链表元素
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 
思路一 : 递归写法
~~~
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //试试递归
        if(!head)
            return head;
        
        if(head->val == val){
            return removeElements(head->next,val);
        }

        head->next = removeElements(head->next,val);

        return head;
    }
};
~~~

思路二 : 迭代的写法...(每写一个while,要明确while结束时程序的状态);
~~~
ListNode* removeElements(ListNode* head, int val) {
        //试试迭代的写法
        if(!head)
            return head;

        ListNode* tmp = new ListNode(-1);
        ListNode* pre = tmp;
        ListNode* cur = head;
        
        while(cur)
        {
            if(cur->val == val)
            {
                cur = cur->next;
            }
            else
            {
                pre->next = cur;
                pre = cur;
                cur = cur->next;
                pre->next = nullptr;
            }
        }

        return tmp->next;
    }
~~~


### 707.设计链表
在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点

...看着简单,实际上还是有些细节需要注意
~~~
class MyLinkedList {
public:
    struct Node
    {
        int val;
        Node* next;

        Node(int v,Node* n = nullptr):
            next(n),
            val(v)
        {}
    };

    Node* head;

    MyLinkedList() {
        head = nullptr;
    }
    
    int get(int index) {
        Node* cur = head;
        for(int i = 0;i<index;i++){
            if(!cur){
                return -1;
            }else{
                cur = cur->next;
            }
        }

        if(!cur){
            return -1;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        Node* node = new Node(val);
        if(!head){
            head = node;
        }else{
            node->next = head;
            head = node;
        }
    }
    
    void addAtTail(int val) {
        Node* node = new Node(val);
        Node* cur = head;
        Node* pre = nullptr;
        while(cur){
            pre = cur;
            cur = cur->next;
        }
        if(!pre){
            head = node;
        }else{
            pre->next = node;
        }

        //打印一哈
        cur = head;
        
    }
    
    void addAtIndex(int index, int val) {
        Node* pre = nullptr;
        Node* cur = head;
        for(int i = 0;i<index;i++){
            if(!cur){
                return;
            }else{
                pre = cur;
                cur = cur->next;
            }
        }

        if(!cur){
            addAtTail(val);
        }

        if(!pre){
            //在头结点插入
            addAtHead(val);
            return;
        }
        Node* node = new Node(val);
        pre->next = node;
        node->next = cur;
        
    }
    
    void deleteAtIndex(int index) {
        if(!head){
            return;
        }
        
        Node* pre = nullptr;
        Node* cur = head;
        for(int i = 0;i<index;i++)
        {
            pre = cur;
            cur = cur->next;
            if(!cur)
                return;
        }
        if(!pre){
            //该判断还是要判断...
            //删除头结点
            Node* tmp =head;
            head = head->next;
            delete tmp;

            return ;
        }
        //cur指向index的节点且节点存在
        pre->next = cur->next;
        delete cur;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
~~~

### 206.反转链表
典中典中典
~~~
ListNode* reverseList(ListNode* head) {
    //从后往前将链表的节点翻转
    if(!head || !head->next)
        return head;
    //head->head->next->head->next->next...
    ListNode* node = reverseList(head->next);

    head->next->next = head;
    head->next = nullptr;

    return node;
}
~~~

### 24.两两交换链表中的结点
链表问题很多时候引入一个开头的僵尸节点就会方便很多很多...
~~~
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        ListNode* tmp = dummy;
        tmp->next = head;

        //存在两个组对的节点
        while(tmp->next && tmp->next->next)
        {
            ListNode* left = tmp->next;
            ListNode* right = tmp->next->next;

            tmp->next = right;
            left->next = right->next;
            right->next = left;
            //交换完成
            tmp = left;//tmp指向下一对节点的前一个节点
        }

        ListNode*res = dummy->next;
        delete dummy;
        return res;
    }
~~~


### 19.删除链表的倒数第N个节点
典
~~~
ListNode* removeNthFromEnd(ListNode* head, int n) {
        //删倒数第N个,就是要找倒数第N+1个节点...
        if(!head){return head;}

        ListNode* fast = head;
        for(int i = 0;i<n;i++)
        {
            fast = fast->next;
        }
        if(!fast)
        {
            //要删除的就是头结点
            ListNode* tmp =head;
            head = head->next;
            delete tmp;
            return head;
        }

        ListNode* slow = head;
        while(fast->next){
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* t = slow->next;
        slow->next = slow->next->next;
        delete t;

        return head;
    }
~~~


### 02.07. 链表相交
典!
~~~
   int getListLen(ListNode* head)
    {
        int count = 0;
        while(head){
            count++;
            head = head->next;
        }

        return count;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getListLen(headA);
        int lenB = getListLen(headB);

        ListNode* theLong = lenA > lenB ? headA : headB;
        ListNode* theShort = lenA > lenB ? headB : headA;

        int interval = abs(lenA - lenB);
        for(int i = 0;i<interval;i++){
            theLong = theLong->next;
        }

        while(theLong && theShort){
            if(theLong == theShort){
                return theLong;
            }
            theLong = theLong->next;
            theShort = theShort->next;
        }

        return nullptr;
    }
~~~


### 142. 环形链表2
...链表题目怎么都是典中典???
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。


经典的快慢指针...
快慢指针相遇于        A点
x + A->尾 + 尾-> 环的开始 -> A典 = 2x
即 x = A->tail + tail -> 环的开始.
所以快指针这时候回到开头,然后和慢指针一样的速度前进就可以和慢指针在环开始的地方相遇
~~~
ListNode *detectCycle(ListNode *head) {
        if(!head){return nullptr;}
        ListNode* fast = head;
        ListNode* slow = head;

        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;

            if(fast == slow){
                break;
            }
        }

        if(!fast || !fast->next){
            return nullptr;
        }

        fast = head;
       
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
            
        }

        return fast;
    }

~~~


## Hash Table
### 242. 有效的字母异位词
~~~
bool isAnagram(string s, string t) {
    //首先记录s每个字符出现的次数....
    int hash[26]{0};
    for(auto ch : s){
        hash[ch - 'a']++;
    }

    for(auto ch : t){
        hash[ch - 'a']--;
        if(hash[ch - 'a'] < 0){
            return false;
        }
    }

    for(int i = 0;i<26;i++){
        if(hash[i] != 0){
            return false;
        }
    }

    return true;
}
~~~
### 349.两个数组的交集
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 

~~~
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    vector<int> res;
    int hash[1024]{0};
    for(auto num : nums1){
        hash[num]++;
    }

    for(auto num : nums2){
        if(hash[num] > 0){
            res.push_back(num);
            hash[num] = 0;
        }
    }

    return res;
}
~~~


### 202.快乐数
~~~
    //根据数字计算平方和
    int powerSum(int n)
    {
        int res = 0;
        while(n){
            res += (n%10) * (n%10);
            n /= 10;
        }

        return res;
    }
    bool isHappy(int n) {
        set<int> repeat;
        
        while(n != 1)
        {
            n = powerSum(n);
            if(repeat.find(n) != repeat.end()){
                return false;
            }
            repeat.insert(n);
        }
        return true;

    }
~~~


### 1.两数之和
...梦开始的地方...
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

~~~
vector<int> twoSum(vector<int>& nums, int target) {
        //梦开始的地方
        unordered_map<int,int>hash_map;//val - index
        
        for(int i = 0;i<nums.size();i++)
        {
            auto iter = hash_map.find(target - nums[i]);
            if(iter != hash_map.end()){
                return {iter->second,i};
            }
            hash_map.insert({nums[i],i});
        }

        
        return {};
    }
~~~


### 454.四数相加
~~~
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        //...遍历nums1 , nums2 ,两两相加加入hash表,然后遍历Nums3 , nums4两两相加,然后寻找hash表内是否存在负值
        unordered_map<int,int>hash;
        for(auto v1 : nums1)
        {
            for(auto v2 : nums2)
            {
                hash[v1 + v2]++;
            }
        }

        int res = 0;
        for(auto v3 : nums3)
        {
            for(auto v4 : nums4)
            {
                int n = v3 + v4;
                auto iter = hash.find(-n);
                if(iter != hash.end()){
                    res += iter->second;
                }
            }
        }

        return res;
    }
~~~


### 383.赎金信
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。
~~~
bool canConstruct(string ransomNote, string magazine) {
    unordered_map<char,int>hash;
    for(auto ch : magazine){
        hash[ch]++;
    }

    for(auto ch : ransomNote){
        if(--hash[ch] < 0){
            return false;
        }
    }

    return true;
}
~~~

### 15.三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 //...这题似乎并不适合用哈希表的方法去做.因为无论怎样都要包含
 ~~~
    vector<vector<int>> threeSum(vector<int>& nums){
        vector<vector<int>>res;
        //将nums排序,方便去重
        sort(nums.begin(),nums.end());

        for(int i = 0;i<nums.size();i++)
        {
            unordered_set<int>hash;
            //最小的元素 > 0,不可能有三元组
            if(nums[i] > 0)
                break;
            
            if(i > 0 && nums[i] == nums[i-1]){
                continue;//跳过重复
            }
            
            for(int j = i + 1;j < nums.size();j++)
            {
                //b 和 c不能相等两次,连续的三个数字不能相等,否则会出现b的重复选择.
                if(j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]){
                    continue;
                }

                int n = -(nums[i] + nums[j]);
                if(hash.find(n)!= hash.end()){
                    res.push_back({nums[i],nums[j],n});
                    hash.erase(n);
                }else{
                    hash.insert(nums[j]);//nums[j]是b
                }
                
                
            }
            
        }
        return res;
    }
~~~
去重去的头疼....

更好的解法 : 双指针法
~~~
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>>res;
        sort(nums.begin(),nums.end());
        if(nums.size() < 3){
            return {};
        }
        for(int i = 0;i<nums.size()-2;i++)
        {
            //i去重
            if(nums[i] > 0)
                break;

                
            if(i > 0 && nums[i] == nums[i-1])
                continue;

            int left = i + 1;int right = nums.size()-1;
            while(left < nums.size()-1 && right > i+1 && left < right)
            {
                //left去重
                if(left > i + 1)
                {
                    if(nums[left] == nums[left-1])
                    {
                        left++;
                        continue;
                    }
                }

                //right去重
                if(right < nums.size()-1){
                    if(nums[right] == nums[right+1]){
                        right--;
                        continue;
                    }
                }

                int cur_val = nums[i] + nums[left] + nums[right];
                if(cur_val == 0){
                    res.push_back({nums[i],nums[left],nums[right]});
                    left++;right--;//找到答案,同时收缩.
                }else if(cur_val > 0){
                    //过大,right左移
                    right--;
                }else{
                    //过小,left右移动
                    left++;
                }

            }
        }

        return res;
    }
~~~
...感觉有点像滑动窗口



### 18.四数之和
~~~
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>>res;
    sort(nums.begin(),nums.end());
    for(int i = 0;i<nums.size();i++)
    {
        if(nums[i] > target && nums[i] >= 0)
            break;

        if(i > 0 && nums[i] == nums[i-1]){
            continue;
        }
        for(int j = i + 1;j<nums.size();j++)
        {
            if(nums[i] + nums[j] > target && nums[i] + nums[j] >= 0)
                break;

            if(j > i + 1 && nums[j] == nums[j-1]){
                continue;
            }

            int left = j + 1; int right = nums.size()-1;
            while(left < right)
            {
                
                if((long) nums[i] + nums[j] + nums[left] + nums[right] < target){
                    left++;
                }else if((long) nums[i] + nums[j] + nums[left] + nums[right] > target){
                    right--;
                }else{
                    res.push_back({nums[i],nums[j],nums[left],nums[right]});
                    while(left < right && nums[left] == nums[left+1])left++;
                    while(left < right && nums[right] == nums[right-1]) right--;

                    left++;
                    right--;
                }
            }
        }
    }

    return res;
}
~~~



## String

### 344. 反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题

...ez
~~~
void reverseString(vector<char>& s) {
    int left = 0;int right = s.size()-1;
    while(left < right)
    {
        swap(s[left++],s[right--]);
    }
}
~~~


### 541.反转字符串2.0
~~~
void func(string& s,int index,int length)
{
    int left = index;
    int right = index + length - 1;

    while(left < right)
    {
        swap(s[left++],s[right--]);
    }
}
string reverseStr(string s, int k) {
    int index = 0;  
    int size = s.size();

    while(index < size)
    {
        //看看够不够k
        if(index + k - 1 < size)
        {
            func(s,index,k);
        }
        else
        {
            //不够k
            func(s,index,size - index);
        }
        index += 2 * k;
    }
    
    return s;
}
~~~


### 剑指Offer 05.替换空格
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1： 输入：s = "We are happy."
输出："We%20are%20happy."

不能使用额外的内存空间
~~~
string replaceSpace(string s) {
    //要求不能使用额外的地址空间...
    int count = 0;
    for(auto ch : s)
    {
        if(ch == ' ')
            count++;
    }

    int front = s.size() - 1;
    s.resize(s.size() + 2 * count);

    //两个指针从后往前,如果直到前面的指针 == 0
    int last = s.size()-1;

    while(front >= 0)
    {
        if(s[front] == ' ')
        {
            s[last--] = '0';
            s[last--] = '2';
            s[last--] = '%';
            front--;
        }
        else
        {
            s[last--] = s[front--];
        }
    }

    return s;
}
~~~


### 151.反转字符串种的单词
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。


不能使用辅助空间...

移除字符串中所有额外的字符串写的很好.
用for(;;)(if(s[i] != ) {} ) 去排除空格的情况,这样的filter写法学到了...
~~~
class Solution {
public:
    void reverse(string& s,int start,int end)
    {
        while(start < end)
        {
            swap(s[start++],s[end--]);
        }
    }

    //移除字符串所有中的字符串
    void removeExtraSpaces(string&s)
    {
        int slow = 0;
        for(int i = 0;i < s.size();i++)
        {
            //如果遇到的不是空格我就自己加上一个空格
            if(s[i] != ' ')
            {
                if(slow != 0)//并不位于开头
                {
                    s[slow++] = ' ';
                }
                //开始录入单词
                while(i < s.size() && s[i] != ' '){
                    s[slow++] = s[i++];
                }
            }
        }

        s.resize(slow);

    }
    //不能使用辅助空间
    string reverseWords(string s) {
        //首先去除所有的空格...,先整体反转一遍...然后对每个单词进行翻转
        removeExtraSpaces(s);

        //整体翻转
        reverse(s,0,s.size()-1);

        for(int i = 0;i<s.size();i++)
        {
            if(s[i] != ' ')
            {
                int fast = i;
                while(fast < s.size() && s[fast] != ' ')
                    fast++;
                //定位到单词,开始反转
                reverse(s,i,fast-1);
                i = fast;
            }
        }

        return s;
    }
};
~~~


